*&---------------------------------------------------------------------*
*& Report  ZDOWN
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  ZDOWN.


*-----------------------------------------------------------------------
*  SAP Tables
*-----------------------------------------------------------------------
tables: trdir, seoclass, tfdir, enlfdir, dd02l.

*-----------------------------------------------------------------------
*  Types
*-----------------------------------------------------------------------
* text element structure
types: tTextTable like textpool.
* GUI titles
types: tGUITitle like d347t.

* Message classes
types: begin of tMessage,
         arbgb like t100-arbgb,
         stext like t100a-stext,
         msgnr like t100-msgnr,
         text  like t100-text,
       end of tMessage.

* Screen flow.
types: begin of tScreenFlow,
         screen like d020s-dnum,
         code like d022s-line,
       end of tScreenFlow.

* Holds a table\structure definition
types: begin of tDictTableStructure,
         fieldname like dd03l-fieldname,
         position  like dd03l-position,
         keyflag   like dd03l-keyflag,
         rollname  like dd03l-rollname,
         domname   like dd03l-domname,
         datatype  like dd03l-datatype,
         leng      like dd03l-leng,
         ddtext    like dd04t-ddtext,
       end of tdictTableStructure.

* Holds a tables attributes + its definition
types: begin of tDictTable,
         tablename    like dd03l-tabname,
         tableTitle   like dd02t-ddtext,
         iStructure type tDictTableStructure occurs 0,
       end of tDictTable.

* Include program names
types: begin of tInclude,
         includeName like trdir-name,
         includeTitle like tftit-stext,
       end of tInclude.

* Exception class texts
types: begin of tConcept,
         constName type string,
         concept type sotr_conc,
       end of tConcept.

* Method
types: begin of tMethod,
         cmpName like vseomethod-cmpname,
         descript like vseomethod-descript,
         exposure like vseomethod-exposure,
         methodKey type string,
       end of tMethod.

* Class
types: begin of tClass,
         scanned(1),
         clsname like vseoclass-clsname,
         descript like vseoclass-descript,
         msg_id like vseoclass-msg_id,
         exposure like vseoclass-exposure,
         state like vseoclass-state,
         clsfinal like vseoclass-clsfinal,
         r3release like vseoclass-r3release,
         iMethods type tMethod occurs 0,
         iDictStruct type tDictTable occurs 0,
         iTextElements type tTextTable occurs 0,
         iMessages type tMessage occurs 0,
         iConcepts type tConcept occurs 0,
         textElementKey type string,
         publicClassKey type string,
         privateClassKey type string,
         protectedClassKey type string,
         typesClassKey type string,
         exceptionClass type i,
       end of tClass.

* function modules
types: begin of tFunction,
         functionName like tfdir-funcName,
         functionGroup like enlfdir-area,
         includeNumber like tfdir-include,
         functionMainInclude like tfdir-funcName,
         functionTitle like tftit-stext,
         topIncludeName like tfdir-funcName,
         progname like tfdir-pname,
         programLinkName like tfdir-pname,
         messageClass like t100-arbgb,
         iTextElements type tTextTable occurs 0,
         iSelectiontexts type tTextTable occurs 0,
         iMessages type tMessage occurs 0,
         iIncludes type tInclude occurs 0,
         iDictStruct type tDictTable occurs 0,
         iGUITitle type tGUITitle occurs 0,
         iScreenFlow type tScreenFlow occurs 0,
       end of tFunction.

types: begin of tProgram,
         progname like trdir-name,
         programTitle like tftit-stext,
         subc like trdir-subc,
         messageClass like t100-arbgb,
         iMessages type tMessage occurs 0,
         iTextElements type tTextTable occurs 0,
         iSelectiontexts type tTextTable occurs 0,
         iGUITitle type tGUITitle occurs 0,
         iScreenFlow type tScreenFlow occurs 0,
         iIncludes type tInclude occurs 0,
         iDictStruct type tDictTable occurs 0,
       end of tProgram.

*-----------------------------------------------------------------------
*  Internal tables
*-----------------------------------------------------------------------
*  Dictionary object
data: iDictionary type standard table of tDictTable with header line.
* Function modules.
data: iFunctions type standard table of tFunction with header line.
* Tree display structure.
data: iTreeDisplay type standard table of snodetext with header line.
* Message class data
data: iMessages type standard table of tMessage with header line.
* Holds a single message class an all of its messages
data: iSingleMessageClass type standard table of tMessage with header
line.
* Holds program related data
data: iPrograms type standard table of tProgram with header line.
* Classes
data: iClasses type standard table of tClass with header line.
* Table of paths created on the SAP server
data: iServerPaths type standard table of string with header line.

*-----------------------------------------------------------------------
*  Table prototypes
*-----------------------------------------------------------------------
data: dumiDictStructure type standard table of tDictTableStructure.
data: dumiTextTab type standard table of tTextTable.
data: dumiIncludes type standard table of tInclude.
data: dumiHtml type standard table of string.
data: dumiHeader type standard table of string .
data: dumiScreen type standard table of tScreenFlow .
data: dumIGUITitle type standard table of tGUITitle.
data: dumiMethods type standard table of tMethod.
data: dumiConcepts type standard table of tConcept.

*-----------------------------------------------------------------------
*   Global objects
*-----------------------------------------------------------------------
data: objFile type ref to cl_gui_frontend_services.
data: objRuntimeError type ref to cx_root.

*-----------------------------------------------------------------------
*  Constants
*-----------------------------------------------------------------------
constants: VERSIONNO type string value '1.3.1'.
constants: TABLES type string value 'TABLES'.
constants: TABLE type string value 'TABLE'.
constants: LIKE type string value 'LIKE'.
constants: TYPE type string value 'TYPE'.
constants: TYPEREFTO type string value 'TYPE REF TO'.
constants: STRUCTURE type string value 'STRUCTURE'.
constants: LOWSTRUCTURE type string value 'structure'.
constants: OCCURS type string value 'OCCURS'.
constants: FUNCTION type string value 'FUNCTION'.
constants: CALLFUNCTION type string value ' CALL FUNCTION'.
constants: MESSAGE type string  value 'MESSAGE'.
constants: INCLUDE type string value 'INCLUDE'.
constants: LOWINCLUDE type string value 'include'.
constants: DESTINATION type string value 'DESTINATION'.
constants: IS_TABLE type string value 'T'.
constants: IS_PROGRAM type string value 'P'.
constants: IS_SCREEN type string value 'S'.
constants: IS_GUITITLE type string value 'G'.
constants: IS_DOCUMENTATION type string value 'D'.
constants: IS_MESSAGECLASS type string value 'MC'.
constants: IS_FUNCTION type string value 'F'.
constants: IS_CLASS type string value 'C'.
constants: IS_METHOD type string value 'M'.
constants: ASTERIX type string value '*'.
constants: COMMA type string value ','.
constants: PERIOD type string value '.'.
constants: DASH type string value '-'.
constants: TRUE type i value 1.
constants: FALSE type i value 0.
constants: LT type string value '&lt;'.
constants: GT type string value '&gt;'.
constants: UNIX type string value 'UNIX'.
constants: NON_UNIX type string value 'not UNIX'.
constants: BACKGROUND_COLOUR type string value '#FFFFE0'.
constants: COLOUR_WHITE type string value '#FFFFFF'.
constants: COLOUR_BLACK type string value '#000000'.
constants: COLOUR_YELLOW type string value '#FFFF00'.
constants: COMMENT_COLOUR type string value '#0000FF'.
constants: HTMLEXTENSION type string value 'html'.
constants: TEXTEXTENSION type string value 'txt'.

*-----------------------------------------------------------------------
*  Global variables
*-----------------------------------------------------------------------
data: statusBarMessage(100).
data: forcedExit type i value 0.
data: startTime like sy-uzeit.
data: runTime like sy-uzeit.
data: downloadFileExtension type string.
data: downloadFolder type string.
data: serverSlashSeparator type string.
data: frontendSlashSeparator type string.
data: slashSeparatorToUse type string.
data: serverFilesystem type filesys_d.
data: serverFolder type string.
data: frontendOpSystem type string.
data: serverOpSystem type string.
data: customerNameSpace type string.
ranges: soProgramName for trdir-name.
ranges: soAuthor for usr02-bname.
ranges: soTableNames for dd02l-tabname.
ranges: soFunctionName  for tfdir-funcName.
ranges: soClassName for vseoclass-clsname.
ranges: soFunctionGroup for enlfdir-area.
field-symbols: <waDictStruct> type tDictTable.

*-----------------------------------------------------------------------
*  Selection screen declaration
*-----------------------------------------------------------------------
* Author
selection-screen: begin of block b1 with frame title tBlock1.
  selection-screen begin of line.
    selection-screen comment 5(23) tAuth.
    parameters: pAuth like usr02-bname memory id MAUTH.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 5(36) tPmod.
    parameters: pMod as checkbox.
  selection-screen end of line.

* Local objects
  selection-screen begin of line.
    selection-screen comment 5(36) t$tmp.
    parameters: p$tmp as checkbox default ''.
  selection-screen end of line.
selection-screen: end of block b1.

selection-screen begin of block b2 with frame title tBlock2.
* Tables
  selection-screen begin of line.
    parameters: rTable radiobutton group r1.
    selection-screen comment 5(15) tRtable.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(15) tPtable.
    select-options: soTable for dd02l-tabname.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(79) tTnote.
  selection-screen end of line.

* Message classes
  selection-screen begin of line.
    parameters: rMess radiobutton group r1.
    selection-screen comment 5(18) tPMes.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(18) tMname.
    parameters: pMname like t100-arbgb memory id MMNAME.
  selection-screen end of line.

* Function modules
  selection-screen begin of line.
    parameters: rFunc radiobutton group r1.
    selection-screen comment 5(30) tRfunc.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(15) tPfname.
    select-options: soFname for tfdir-funcName.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(15) tFgroup.
    select-options: soFgroup for enlfdir-area.
  selection-screen end of line.

* Classes
  selection-screen begin of line.
    parameters: rClass radiobutton group r1.
    selection-screen comment 5(30) tRClass.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(15) tPcName.
    select-options: soClass for seoclass-clsname.
  selection-screen end of line.

* Programs / includes
  selection-screen begin of line.
    parameters: rProg radiobutton group r1 default 'X'.
    selection-screen comment 5(18) tProg.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(15) tRpname.
    select-options: soProg for trdir-name.
  selection-screen end of line.

  selection-screen skip.
* Language
  selection-screen begin of line.
    selection-screen comment 1(18) tMLang.
    parameters: pMLang like t100-sprsl default 'EN'.
  selection-screen end of line.

* Package
  selection-screen begin of line.
    selection-screen comment 1(18) tPack.
    parameters: pPack like tadiv-devclass memory id MPACK.
  selection-screen end of line.

* Customer objects
  selection-screen begin of line.
    selection-screen comment 1(27) tCust.
    parameters: pCust as checkbox default 'X'.
    selection-screen comment 32(25) tNRange.
    parameters: pCName type namespace memory id MNAMESPACE.
  selection-screen end of line.
selection-screen: end of block b2.

* Additional things to download.
selection-screen: begin of block b3 with frame title tBlock3.
  selection-screen begin of line.
    selection-screen comment 1(33) tPtext.
    parameters: pText as checkbox default 'X' memory id MTEXT.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tMess.
    parameters: pMess as checkbox default 'X' memory id MMESS.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tPinc.
    parameters: pInc as checkbox default 'X' memory id MINC.
    selection-screen comment 40(20) tRecc.
    parameters: pReci as checkbox default 'X' memory id MRECI.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tPfunc.
    parameters: pFunc as checkbox default 'X' memory id MFUNC.
    selection-screen comment 40(20) tRecf.
    parameters: pRecf as checkbox default 'X' memory id MRECF.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tDoc.
    parameters: pDoc as checkbox default 'X' memory id MDOC.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tPscr.
    parameters: pScr as checkbox default 'X' memory id MSCR.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tPdict.
    parameters: pDict as checkbox default 'X' memory id MDICT.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tSortT.
    parameters: pSortT as checkbox default ' ' memory id MSORTT.
  selection-screen end of line.
selection-screen: end of block b3.

* File details
selection-screen: begin of block b4 with frame title tBlock4.
  selection-screen begin of line.
    selection-screen comment 1(20) tPhtml.
    parameters: pHtml radiobutton group g1 default 'X'.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 5(29) tComm.
    parameters: pComm as checkbox default 'X'.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 5(29) tBack.
    parameters: pBack as checkbox default 'X'.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(20) tPtxt.
    parameters: pTxt radiobutton group g1.
  selection-screen end of line.

  selection-screen skip.

* Download to SAP server
  selection-screen begin of line.
    selection-screen comment 1(25) tServ.
    parameters: pServ radiobutton group g2.
  selection-screen end of line.
  selection-screen begin of line.
    selection-screen comment 8(20) tSPath.
    parameters: pLogical like filename-fileintern memory id MLOGICAL.
  selection-screen end of line.
  selection-screen comment /28(60) tSDPath.

* Download to PC
  selection-screen begin of line.
    selection-screen comment 1(25) tPc.
    parameters: pPc radiobutton group g2 default 'X'.
  selection-screen end of line.
  selection-screen begin of line.
    selection-screen comment 8(20) tPpath.
    parameters: pFolder like rlgrap-filename memory id MFOLDER.
  selection-screen end of line.
selection-screen: end of block b4.

* Display options
selection-screen: begin of block b5 with frame title tBlock5.
* Display final report
  selection-screen begin of line.
    selection-screen comment 1(33) tRep.
    parameters: pRep as checkbox default 'X'.
  selection-screen end of line.
* Display progress messages
  selection-screen begin of line.
    selection-screen comment 1(33) tProMess.
    parameters: pProMess as checkbox default 'X'.
  selection-screen end of line.
selection-screen: end of block b5.

*-----------------------------------------------------------------------
* Display a directory picker window
*-----------------------------------------------------------------------
at selection-screen on value-request for pFolder.

data: objFile type ref to cl_gui_frontend_services.
data: pickedFolder type string.
data: initialFolder type string.

  if sy-batch is initial.
    create object objFile.

    if not pFolder is initial.
      initialFolder = pFolder.
    else.
      objFile->get_temp_directory( changing temp_dir = initialFolder
                                   exceptions cntl_error = 1
                                             error_no_gui = 2
                                             not_supported_by_gui = 3 ).
    endif.

    objFile->directory_browse( exporting initial_folder = initialFolder
                               changing selected_folder = pickedFolder
                               exceptions cntl_error = 1
                                          error_no_gui = 2
                                          not_supported_by_gui = 3 ).

    if sy-subrc = 0.
      pFolder = pickedFolder.
    else.
      write: / 'An error has occured picking a folder'.
    endif.
  endif.

*-----------------------------------------------------------------------
at selection-screen.
*-----------------------------------------------------------------------
  case 'X'.
    when pPc.
      if pFolder is initial.
*       User must enter a path to save to
        message e000(oo) with 'You must enter a file path'.
      endif.

    when pServ.
      if pLogical is initial.
*       User must enter a logical path to save to
        message e000(oo) with 'You must enter a logical file name'.
      endif.
  endcase.

*-----------------------------------------------------------------------
at selection-screen on pLogical.
*-----------------------------------------------------------------------

  if not pServ is initial.
    call function 'FILE_GET_NAME' exporting logical_filename = pLogical
                                  importing file_name = serverFolder
                                  exceptions file_not_found = 1
                                             others = 2.
    if sy-subrc = 0.
      if serverFolder is initial.
        message e000(oo) with 'No file path returned from logical filename'.
      else.
*       Path to display on the selection screen
        tSDPath = serverFolder.
*       Remove the trailing slash off the path as the subroutine
*buildFilename will add an extra one
        shift serverFolder right deleting trailing serverSlashSeparator.
        shift serverFolder left deleting leading space.
      endif.
    else.
      message e000(oo) with 'Logical filename does not exist'.
    endif.
  endif.

*
at selection-screen on value-request for soProg-low.
*
  call function 'REPOSITORY_INFO_SYSTEM_F4' exporting object_type  =
'PROG'
                                                      object_name  =
soProg-low
                                                      suppress_selection
   = 'X'
                                                      use_alv_grid = ''

without_personal_list = ''
                                            importing
object_name_selected = soProg-low
                                            exceptions cancel = 1.

*
at selection-screen on value-request for soProg-high.
*
  call function 'REPOSITORY_INFO_SYSTEM_F4' exporting object_type  =
'PROG'
                                                      object_name  =
soProg-high
                                                      suppress_selection
   = 'X'
                                                      use_alv_grid = ''

without_personal_list = ''
                                            importing
object_name_selected = soProg-high
                                            exceptions cancel = 1.

*
at selection-screen on value-request for soClass-low.
*
  call function 'F4_DD_ALLTYPES' exporting object = soClass-low
                                           suppress_selection = 'X'
                                           display_only = ''
                                           only_types_for_clifs = 'X'
                                 importing result = soClass-low.

*
at selection-screen on value-request for soClass-high.
*
  call function 'F4_DD_ALLTYPES' exporting object = soClass-high
                                           suppress_selection = 'X'
                                           display_only = ''
                                           only_types_for_clifs = 'X'
                                 importing result = soClass-high.

*-----------------------------------------------------------------------
at selection-screen on value-request for soFName-low.
*-----------------------------------------------------------------------
  call function 'REPOSITORY_INFO_SYSTEM_F4' exporting object_type  =
'FUNC'
                                                      object_name  =
soFname-low
                                                      suppress_selection
   = 'X'
                                                      use_alv_grid = ''

without_personal_list = ''
                                            importing
object_name_selected = soFName-low
                                            exceptions cancel = 1.

*-----------------------------------------------------------------------
at selection-screen on value-request for soFName-high.
*-----------------------------------------------------------------------
  call function 'REPOSITORY_INFO_SYSTEM_F4' exporting object_type  =
'FUNC'
                                                      object_name  =
soFname-high
                                                      suppress_selection
   = 'X'
                                                      use_alv_grid = ''

without_personal_list = ''
                                            importing
object_name_selected = soFName-high
                                            exceptions cancel = 1.

*-----------------------------------------------------------------------
at selection-screen on value-request for soFGroup-low.
*-----------------------------------------------------------------------
  call function 'REPOSITORY_INFO_SYSTEM_F4' exporting object_type  =
'FUGR'
                                                      object_name  =
soFGroup-low
                                                      suppress_selection
   = 'X'
                                                      use_alv_grid = ''

without_personal_list = ''
                                            importing
object_name_selected = soFGroup-low
                                            exceptions cancel = 1.

*-----------------------------------------------------------------------
at selection-screen on value-request for soFGroup-high.
*-----------------------------------------------------------------------
  call function 'REPOSITORY_INFO_SYSTEM_F4' exporting object_type  =
'FUGR'
                                                      object_name  =
soFGroup-high
                                                      suppress_selection
   = 'X'
                                                      use_alv_grid = ''

without_personal_list = ''
                                            importing
object_name_selected = soFGroup-high
                                            exceptions cancel = 1.

*-----------------------------------------------------------------------
* initialisation
*-----------------------------------------------------------------------
initialization.
* Parameter screen texts.
  tBlock1 = 'Author (Optional)'.
  t$tmp   = 'Programs only: include local objects'.
  tBlock2 = 'Objects to download'.
  tBlock3 = 'Additional downloads for programs, function modules and classes'.
  tBlock4 = 'Download parameters'.
  tBlock5 = 'Display options'.
  tAuth   = 'Author name'.
  tPmod   = 'Include programs modified by author'.
  tCust   = 'Only customer objects'.
  tNRange = 'Alt customer name range'.
  tRtable = 'Tables / Structures'.
  tPtable = 'Table name'.
  tTnote  = 'Note: tables are stored under the username of the last person who modified them'.
  tRfunc  = 'Function modules'.
  tPfname = 'Function name'.
  tFgroup = 'Function group'.
  tRClass  = 'Classes'.
  tPcname = 'Class name'.
  tMess   = 'Message class'.
  tMName  = 'Class name'.
  tMLang  = 'Language'.
  tProg   = 'Programs'.
  tRpname = 'Program name'.
  tPack   = 'Package'.
  tPtxt   = 'Text document'.
  tPhtml  = 'HTML document'.
  tComm   = 'Highlight comments'.
  tBack   = 'Include background colour'.
  tPtext  = 'Text elements'.
  tPinc   = 'Include programs'.
  tRecc   = 'Recursive search'.
  tPpath  = 'File path'.
  tSPath  = 'Logical file name'.
  tPmes   = 'Message classes'.
  tPfunc  = 'Function modules'.
  tDoc    = 'Function module documentation'.
  tRecf   = 'Recursive search'.
  tPscr   = 'Screens'.
  tPdict  = 'Dictionary structures'.
  tSortT  = 'Sort table fields alphabetically'.
  tServ   = 'Download to server'.
  tPc     = 'Download to PC'.
  tRep    = 'Display download report'.
  tProMess  = 'Display progress messages'.

* Determine the frontend operating system type.
  if sy-batch is initial.
    perform determineFrontendOPSystem using frontendSlashSeparator
frontendOpSystem.
  endif.
  perform determineServerOpsystem using serverSlashSeparator
serverFileSystem serverOpsystem.

* Determine if the external command exists.  If it doesn't then disable
* the server input field
  perform findExternalCommand.

*-----------------------------------------------------------------------
* start-of-selection.
*-----------------------------------------------------------------------
start-of-selection.

  perform checkComboBoxes.
  perform fillSelectionRanges.
  startTime = sy-uzeit.

* Don't display status messages if we are running in the background
  if not sy-batch is initial.
    pProMess = ''.
  endif.

* Fool the HTML routines to stop them hyperlinking anything with a space
* in them
  if pCName is initial.
    customerNameSpace  = '^'.
  else.
    customerNameSpace = pCName.
  endif.

* Determine which operating slash and download directory to use
  case 'X'.
    when pPc.
      slashSeparatorToUse = frontendSlashSeparator.
      downloadFolder = pFolder.
    when pServ.
      slashSeparatorToUse = serverSlashSeparator.
      downloadFolder = serverFolder.
  endcase.

* Main program flow.
  case 'X'.
*   Select tables
    when rTable.
      perform retrieveTables using iDictionary[]
                                   soTableNames[]
                                   soAuthor[].

*   Select message classes tables
    when rMess.
      perform retrieveMessageClass using iMessages[]
                                         soAuthor[]      "Author
                               pMname          "Message class name
                               pMLang          "Message class language
                               pMod.           "Modified by author

*   Select function modules
    when rFunc.
      perform retrieveFunctions using soFunctionName[]   "Function name
                                      soFunctionGroup[]  "Function group
                                 iFunctions[]       "Found functions
                                 soAuthor[]         "Author
                                 pText              "Get texte Elements
                                 pScr               "Get screens
                                 pCust              "Customer data
                                 customerNameSpace. "Customer name
"range


      loop at iFunctions.
*       Find Dict structures, messages, functions, includes etc.
        perform scanForAdditionalFuncStuff using iFunctions[]
                                                 pRecI
 "Search for includes recursively
                                                 pRecF
 "Search for functions recursively
                                                 pInc
 "Search for includes
                                                 pFunc
 "Search for functions
                                                 pDict
 "search for dictionary objects
                                                 pMess
 "Search for messages
                                                 pCust
 "Customer data only
                                                 customerNameSpace.
 "Customer name range
      endloop.

*   Select Classes
    when rClass.
      perform retrieveClasses using iClasses[]
                                    iFunctions[]
                                    soClassName[]       "Class name
                                    soAuthor[]          "Author
                                    customerNameSpace   "Customer name
                                    pMod                "Also modified
                                    pCust               "Customer object
                                    pMess               "Find messages
                                    pText               "Text Elements
                                    pDict               "Dictionary
                                    pFunc               "Get functions
                                    pInc                "Get includes
                                    pRecF               "Search
                                    pRecI               "Search
                                    'X'                 "Search
                                    pMLang.             "Language

      loop at iFunctions.
*       Find Dict structures, messages, functions, includes etc.
        perform scanForAdditionalFuncStuff using iFunctions[]
                                                 pRecI
 "Search for includes recursively
                                                 pRecF
 "Search for functions recursively
                                                 pInc
 "Search for includes
                                                 pFunc
 "Search for functions
                                                 pDict
 "search for dictionary objects
                                                 pMess
 "Search for messages
                                                 pCust
 "Customer data only
                                                 customerNameSpace.
 "Customer name range
      endloop.

*   Select programs
    when rProg.
      perform retrievePrograms using iPrograms[]
                                     iFunctions[]
                                     soProgramName[]    "Program name
                                     soAuthor[]         "Author
                                     customerNamespace  "Customer name
                                     pMod               "Also modified
                                     pCust              "Customer object
                                     pMess              "Find messages
                                     pText              "Text Elements
                                     pDict              "Dictionay
                                     pFunc              "Get functions
                                     pInc               "Get includes
                                     pScr               "Get screens
                                     pRecF              "Search
                                     pRecI              "Search
                                     p$Tmp              "local objects
                                     pPack.             "Package
  endcase.

*-----------------------------------------------------------------------
* end-of-selection
*-----------------------------------------------------------------------
end-of-selection.

  if forcedExit = 0.
*   Set the file extension and output type of the file
    if pTxt is initial.
      downloadFileExtension = HTMLEXTENSION.
    else.
      downloadFileExtension = TEXTEXTENSION.
    endif.

*   Decide what to download
    case 'X'.
*     Download tables
      when rTable.
        if not ( iDictionary[] is initial ).
          perform downloadDDStructures using iDictionary[]
                                             downloadFolder
                                             HTMLEXtension
                                             space
                                             pSortT
                                             slashSeparatorToUse
                                             pServ
                                             pProMess.

*         Free up any memory used for caching HTML versions of tables
          loop at iDictionary.
            free memory id iDictionary-tablename.
          endloop.

*         Display donwload report
          if not pRep is initial.
            get time.
            runTime = sy-uzeit - startTime.
            perform fillTreeNodeTables using iDictionary[]
                                             iTreeDisplay[]
                                             runTime.
          endif.

          clear iDictionary[].
        endif.

*     Download message class
      when rMess.
        if not ( iMessages[] is initial ).
          sort iMessages ascending by arbgb msgnr.
          loop at iMessages.
            append iMessages to iSingleMessageClass.
            at end of arbgb.
              perform downloadMessageClass using iSingleMessageClass[]
                                                 iMessages-arbgb
                                                 downloadFolder
                                                 downloadFileExtension
                                                 pHtml
                                                 space
                                                 pComm
                                                 customerNameSpace
                                                 pInc
                                                 pDict
                                                 pMess
                                                 slashSeparatorToUse
                                                 pServ
                                                 pProMess.
              clear iSingleMessageClass[].
            endat.
          endloop.

*         Display download report
          if not pRep is initial.
            get time.
            runTime = sy-uzeit - startTime.
            perform fillTreeNodeMessages using iMessages[]
                                               iTreeDisplay[]
                                               runTime.
          endif.

         clear iMessages[].
       endif.

*     Download functions
      when rFunc.
        if not ( iFunctions[] is initial ).
           perform downloadFunctions using iFunctions[]
                                           downloadFolder
                                           downloadFileExtension
                                           space
                                           pDoc
                                           pHtml
                                           pComm
                                           customerNameSpace
                                           pInc
                                           pDict
                                           TEXTEXTENSION
                                           HTMLEXTENSION
                                           pSortT
                                           slashSeparatorToUse
                                           pServ
                                           pProMess.

*         Free up any memory used for caching HTML versions of tables
          loop at iFunctions.
            loop at iFunctions-iDictStruct assigning <waDictStruct>.
              free memory id <waDictStruct>-tablename.
            endloop.
          endloop.

*         Display donwload report
          if not pRep is initial.
            get time.
            runTime = sy-uzeit - startTime.
            perform fillTreeNodeFunctions using iFunctions[]
                                                iTreeDisplay[]
                                                runTime.
          endif.

          clear iFunctions[].
        endif.

*     Download Classes
      when rClass.
        if not ( iClasses[] is initial ).
          perform downloadClasses using iClasses[]
                                        iFunctions[]
                                        downloadFolder
                                        downloadFileExtension
                                        HTMLEXTENSION
                                        TEXTEXTENSION
                                        pHtml
                                        pComm
                                        customerNameSpace
                                        pInc
                                        pDict
                                        pDoc
                                        pSortT
                                        slashSeparatorToUse
                                        pServ
                                        pProMess.

*         Free up any memory used for caching HTML versions of tables
          loop at iFunctions.
            loop at iFunctions-iDictStruct assigning <waDictStruct>.
              free memory id <waDictStruct>-tablename.
            endloop.
          endloop.

*         Free up any memory used for caching HTML versions of tables
          loop at iPrograms.
            loop at iPrograms-iDictStruct assigning <waDictStruct>.
              free memory id <waDictStruct>-tablename.
            endloop.
          endloop.

*         Display donwload report
          if not pRep is initial.
            get time.
            runTime = sy-uzeit - startTime.
            perform fillTreeNodeClasses using iClasses[]
                                              iFunctions[]
                                              iTreeDisplay[]
                                              runTime.
          endif.

          clear iClasses[].
          clear iFunctions[].
        endif.

*     Download programs
      when rProg.
        if not ( iPrograms[] is initial ).
          perform downloadPrograms using iPrograms[]
                                         iFunctions[]
                                         downloadFolder
                                         downloadFileExtension
                                         HTMLEXTENSION
                                         TEXTEXTENSION
                                         pHtml
                                         pComm
                                         customerNameSpace
                                         pInc
                                         pDict
                                         pDoc
                                         pSortT
                                         slashSeparatorToUse
                                         pServ
                                         pProMess.

*         Free up any memory used for caching HTML versions of tables
          loop at iFunctions.
            loop at iFunctions-iDictStruct assigning <waDictStruct>.
              free memory id <waDictStruct>-tablename.
            endloop.
          endloop.

*         Free up any memory used for caching HTML versions of tables
          loop at iPrograms.
            loop at iPrograms-iDictStruct assigning <waDictStruct>.
              free memory id <waDictStruct>-tablename.
            endloop.
          endloop.

*         Display donwload report
          if not pRep is initial.
            get time.
            runTime = sy-uzeit - startTime.
            perform fillTreeNodePrograms using iPrograms[]
                                               iFunctions[]
                                               iTreeDisplay[]
                                               runTime.
          endif.

          clear iPrograms[].
          clear iFunctions[].
        endif.
    endcase.

    if not pRep is initial.
      if not ( iTreeDisplay[] is initial ).
        perform displayTree using iTreeDisplay[].
      else.
        statusBarMessage = 'No items found matching selection criteria'.
        perform displayStatus using statusBarMessage 2.
      endif.
    endif.
  endif.

*--- Memory IDs
* User name
  set parameter id 'MAUTH' field pAuth.
* Message class
  set parameter id 'MMNAME' field pMname.
* Customer namespace
  set parameter id 'MNAMESPACE' field pCName.
* Folder
  set parameter id 'MFOLDER' field pFolder.
* Logical filepath
  set parameter id 'MLOGICAL' field pLogical.
* Package
  set parameter id 'MPACK' field pPack.
* Text element checkbox
  set parameter id 'MTEXT' field pText.
* Messages checkbox
  set parameter id 'MMESS' field pMess.
* Includes checkbox
  set parameter id 'MINC' field pInc.
* Recursive includes checkbox.
  set parameter id 'MRECI' field pReci.
* Functions checkbox
  set parameter id 'MFUNC' field pFunc.
* Recursive functions checkbox
  set parameter id 'MRECF' field pRecf.
* Function module documntation checkbox
  set parameter id 'MDOC' field pDoc.
* Screens checkbox
  set parameter id 'MSCR' field pScr.
* Dictionary checkbox
  set parameter id 'MDICT' field pDict.
* Sort table ascending checkBox
  set parameter id 'MSORTT' field pSortT.

************************************************************************
***********************************************
***************************************************SUBROUTINES**********
***********************************************
************************************************************************
***********************************************

*-----------------------------------------------------------------------
*  checkComboBoxes...  Check input parameters
*-----------------------------------------------------------------------
form checkComboBoxes.

  if pAuth is initial.
    case 'X'.
      when rTable.
        if soTable[] is initial.
          statusBarMessage = 'You must enter either a table name or author.'.
        endif.
      when rFunc.
        if ( soFName[] is initial ) and ( soFGroup[] is initial ).
          if soFName[] is initial.
            statusBarMessage = 'You must enter either a function name or author.'.
          else.
            if soFGroup[] is initial.
              statusBarMessage = 'You must enter either a function group, or an author name.'.
            endif.
          endif.
        endif.
      when rProg.
        if soProg[] is initial.
            statusBarMessage = 'You must enter either a program name or author name.'.
        endif.
    endcase.
  else.
*   Check the user name of the person objects are to be downloaded for
    if pAuth = 'SAP*' or pauth = 'SAP'.
      statusBarMessage = 'Sorry cannot download all objects for SAP standard user'.
    endif.
  endif.

  if not statusBarMessage is initial.
    perform displayStatus using statusBarMessage 3.
    forcedExit = 1.
    stop.
  endif.
endform.
                "checkComboBoxes

*-----------------------------------------------------------------------
* fillSelectionRanges...      for selection routines
*-----------------------------------------------------------------------
form fillSelectionRanges.

data: strLength type i.

  strLength = strlen( pcName ).

  if not pAuth is initial.
    soAuthor-sign = 'I'.
    soAuthor-option = 'EQ'.
    soAuthor-low = pAuth.
    append soAuthor.
  endif.

* Tables
  if not soTable is initial.
    soTableNames[] = soTable[].
*   Add in the customer namespace if we need to
    if not pcName is initial.
       loop at soTableNames.
        if soTableNames-low+0(strLength) <> pcName.
          concatenate pcName soTableNames-low into soTableNames-low.
        endif.

        if soTableNames-high+0(strLength) <> pcName.
          concatenate pcName soTableNames-high into soTableNames-high.
        endif.

        modify soTableNames.
      endloop.
    endif.
  endif.

* Function names
  if not soFName is initial.
    soFunctionName[] = soFname[].
*   Add in the customer namespace if we need to
    if not pcName is initial.
       loop at soFunctionName.
        if soFunctionName-low+0(strLength) <> pcName.
          concatenate pcName soFunctionName-low into soFunctionName-low.
        endif.

        if soFunctionName-high+0(strLength) <> pcName.
          concatenate pcName soFunctionName-high into
soFunctionName-high.
        endif.

        modify soFunctionName.
      endloop.
    endif.
  endif.

* Function group
  if not soFGroup is initial.
    soFunctionGroup[] = soFGroup[].
*   Add in the customer namespace if we need to
    if not pcName is initial.
       loop at soFunctionName.
        if soFunctionGroup-low+0(strLength) <> pcName.
          concatenate pcName soFunctionGroup-low into
soFunctionGroup-low.
        endif.

        if soFunctionGroup-high+0(strLength) <> pcName.
          concatenate pcName soFunctionGroup-high into
soFunctionGroup-high.
        endif.

        modify soFunctionGroup.
      endloop.
    endif.
  endif.

* Class names
  if not soClass is initial.
    soClassName[] = soClass[].
*   Add in the customer namespace if we need to
    if not pcName is initial.
       loop at soClassName.
        if soClassName-low+0(strLength) <> pcName.
          concatenate pcName soClassName-low into soClassName-low.
        endif.

        if soClassName-high+0(strLength) <> pcName.
          concatenate pcName soClassName-high into soClassName-high.
        endif.

        modify soClassName.
      endloop.
    endif.
  endif.

* Program names
  if not soProg is initial.
    soProgramName[] = soProg[].
*   Add in the customer namespace if we need to
    if not pcName is initial.
       loop at soProgramName.
        if soProgramName-low+0(strLength) <> pcName.
          concatenate pcName soProgramName-low into soProgramName-low.
        endif.

        if soProgramName-high+0(strLength) <> pcName.
          concatenate pcName soProgramName-high into soProgramName-high.
        endif.

        modify soProgramName.
      endloop.
    endif.
  endif.
endform.
                          " fillSelectionRanges

*-----------------------------------------------------------------------
*  retrieveTables...             Search for tables in dictionary
*-----------------------------------------------------------------------
form retrieveTables using iLocDictStructure like iDictionary[]
                          soTable like soTable[]
                          soAuthor like soAuthor[].

data: waDictStructure type tDictTable.

  select tabname
         from dd02l
         into waDictStructure-tablename
         where tabname in soTable
           and tabclass <> 'CLUSTER'
           and tabclass <> 'POOL'
           and tabclass <> 'VIEW'
           and as4user in soAuthor
           and as4local = 'A'.

    perform findTableDescription using waDictStructure-tablename
                                       waDictStructure-tableTitle.

    perform findTableDefinition using waDictStructure-tableName
                                      waDictStructure-iStructure[].

    append waDictStructure to iLocDictStructure.
    clear waDictStructure.
  endselect.
endform.
                                "retrieveTables

*-----------------------------------------------------------------------
*  findTableDescription...  Search for table description in dictionary
*-----------------------------------------------------------------------
form findTableDescription using value(tableName)
                                      tableDescription.

    select single ddtext
                  from dd02t
                  into tableDescription
                  where tabname = tableName
                   and ddlanguage = sy-langu.
endform.
                          "findTableDescription

*-----------------------------------------------------------------------
*  findTableDefinition... Find the structure of a table from the SAP
*  database.
*-----------------------------------------------------------------------
form findTableDefinition using value(tablename)
                               iDictStruct like dumIDictStructure[].

data gotstate like dcobjif-gotstate.
data: definition type standard table of DD03P with header line.
data: waDictStruct type tDictTableStructure.

  call function 'DDIF_TABL_GET'
       exporting
            name          = tablename
            state         = 'A'
            langu         = sy-langu
       importing
            gotstate      = gotstate
       tables
            dd03p_tab     = definition
       exceptions
            illegal_input = 1
            others        = 2.

  if sy-subrc = 0 and gotstate = 'A'.
    loop at definition.
      move-corresponding definition to waDictStruct.
      perform removeLeadingZeros changing waDictStruct-position.
      perform removeLeadingZeros changing waDictStruct-leng.
      append waDictStruct to iDictStruct.
    endloop.
  endif.
endform.
                           "findTableDefinition

*-----------------------------------------------------------------------
*  retrieveMessageClass...   Retrieve a message class from the SAP
*  database
*-----------------------------------------------------------------------
form retrieveMessageClass using iLocMessages like iMessages[]
                                rangeAuthor like soAuthor[]
                                value(messageClassName)
                                value(messageClassLang)
                                value(modifiedBy).

data: waMessage type tMessage.

  if not messageClassName is initial.
    select * from t100
             appending corresponding fields of table iLocMessages
             where sprsl = messageClassLang
               and arbgb = messageClassName.

    loop at iLocMessages into waMessage.
      select single stext
                    from t100a                "#EC CI_BUFFJOIN
                    into waMessage-stext
                    where arbgb = waMessage-arbgb.
      modify iLocMessages from waMessage index sy-tabix.
    endloop.
  else.
    if modifiedBy is initial.
*     Select by author
      select t100~arbgb                             "#EC CI_BUFFJOIN
             t100~msgnr
             t100~text
             t100a~stext
             appending corresponding fields of table iLocMessages
             from t100
             inner join t100a on t100a~arbgb = t100~arbgb
             where t100a~masterLang = messageClassLang
               and t100a~respUser in rangeAuthor[].
    else.
*     Select also by the last person who modified the message class
      select t100~arbgb                             "#EC CI_BUFFJOIN
             t100~msgnr
             t100~text
             t100a~stext
             appending corresponding fields of table iLocMessages
             from t100
             inner join t100a on t100a~arbgb = t100~arbgb
             where t100a~masterLang = messageClassLang
               and t100a~respUser in rangeAuthor[]
               and t100a~lastUser in rangeAuthor[].
    endif.
  endif.
endform.
                          "retrieveMessageClass

*-----------------------------------------------------------------------
*  retrieveFunctions...   Retrieve function modules from SAP DB.  May be
*  called in one of two ways
*-----------------------------------------------------------------------
form retrieveFunctions using soFName like soFunctionName[]
                             soFGroup like soFunctionGroup[]
                             iLocFunctionNames like iFunctions[]
                             value(solocAuthor) like soAuthor[]
                             value(getTextElements)
                             value(getScreens)
                             value(customerOnly)
                             value(customerNameRange).

ranges: rangeFuncName  for tfdir-funcName.
ranges: rangefuncGroup for enlfdir-area.
data: waFunctionName type tFunction.
data: noGroupsFound type i value TRUE.
data: previousFG type v_fdir-area.

  rangeFuncName[] = soFName[].
  rangeFuncGroup[] = soFGroup[].

  if not soLocAuthor[] is initial.
*-- Need to select all function groups by author
    select area
           from tlibv
           into rangeFuncGroup-low
           where uname in soLocAuthor
             and area in soFGroup[].

      rangeFuncGroup-sign = 'I'.
      rangeFuncGroup-option = 'EQ'.
      append rangeFuncGroup.
      noGroupsFound = FALSE.
    endselect.
  else.
    noGroupsFound = FALSE.
  endif.

  if noGroupsFound = FALSE.
*   select by function name and/or function group.
    select funcName area
                    from v_fdir
                    into (waFunctionName-functionName,
                          waFunctionName-functionGroup)
                    where funcName in rangeFuncName
                      and area in rangeFuncGroup
                      and generated = ''
                      order by area.

      append waFunctionName to iLocFunctionNames.
    endselect.
  endif.

  loop at iLocFunctionNames into waFunctionName.
    perform retrieveFunctionDetail using waFunctionName-functionName
                                         waFunctionName-progname
                                         waFunctionName-includeNumber
                                         waFunctionName-functionTitle.

    perform findMainFunctionInclude using waFunctionName-progname
                                          waFunctionName-includeNumber

waFunctionName-functionMainInclude.

    perform findFunctionTopInclude using waFunctionName-progname
                                         waFunctionName-topIncludeName.

*   Find all user defined includes within the function group
    perform scanForFunctionIncludes using waFunctionName-progname
                                          customerOnly
                                          customerNameRange
                                          waFunctionName-iIncludes[].
*   Find main message class
    perform findMainMessageClass using waFunctionName-progname
                                       waFunctionName-messageClass.

*   Find any screens declared within the main include
    if not getScreens is initial.
      if previousFG is initial or previousFG <>
waFunctionName-functionGroup.
        perform findFunctionScreenFlow using waFunctionName.

*       Search for any GUI texts
        perform retrieveGUITitles using waFunctionName-iGUITitle[]
                                        waFunctionName-progname.
      endif.
    endif.

    if not getTextElements is initial.
*     Find the program texts from out of the database.
      perform retrieveProgramTexts using
waFunctionName-iSelectionTexts[]
                                         waFunctionName-iTextElements[]
                                         waFunctionName-progname.
    endif.

    previousFG = waFunctionName-functionGroup.
    modify iLocFunctionNames from waFunctionName.
  endloop.
endform.
                             "retrieveFunctions

*-----------------------------------------------------------------------
*  retrieveFunctionDetail...   Retrieve function module details from SAP
*  DB.
*-----------------------------------------------------------------------
form retrieveFunctionDetail using value(functionName)
                                        progname
                                        includeName
                                        titleText.

  select single pname
                include
                from tfdir
                into (progname, includeName)
                where funcName = functionName.

  if sy-subrc = 0.
    select single stext
                  from tftit
                  into titleText
                  where spras = sy-langu
                    and funcName = functionName.
  endif.
endform.
                        "retrieveFunctionDetail

*-----------------------------------------------------------------------
*  findMainFunctionInclude...  Find the main include that contains the
*  source code
*-----------------------------------------------------------------------
form findMainFunctionInclude using value(programName)
                                   value(includeNo)
                                         internalIncludeName.
data: newIncludeNumber type string.

  concatenate '%U' includeNo into newIncludeNumber.
  select single include
                from d010inc
                into internalIncludeName
                where master = programName
                  and include like newIncludeNumber.
endform.
                       "findMainFunctionInclude

*-----------------------------------------------------------------------
*  findFunctionTopInclude...  Find the top include for the function
*  group
*-----------------------------------------------------------------------
form findFunctionTopInclude using value(programName)
                                        topIncludeName.

  select single include
                from d010inc
                into topIncludeName
                where master = programName
                  and include like '%TOP'.
endform.
                        "findFunctionTopInclude

*-----------------------------------------------------------------------
* scanForAdditionalFuncStuff... Search for additional things relating to
* functions
*-----------------------------------------------------------------------
form scanForAdditionalFuncStuff using iLocFunctions like iFunctions[]
                                      value(recursiveIncludes)
                                      value(recursiveFunctions)
                                      value(searchForIncludes)
                                      value(searchForFunctions)
                                      value(searchForDictionary)
                                      value(searchForMessages)
                                      value(customerOnly)
                                      value(customerNameRange).

data: waFunction type tFunction.
data: waInclude type tInclude.

  loop at iLocFunctions into waFunction.
    if not searchForIncludes is initial.
*     Search in the main include
      perform scanForIncludePrograms using
 waFunction-functionMainInclude
                                           recursiveIncludes
                                           customerOnly
                                           customerNameRange
                                           waFunction-iIncludes[].

*     Search in the top include
      perform scanForIncludePrograms using waFunction-topIncludeName
                                           recursiveIncludes
                                           customerOnly
                                           customerNameRange
                                           waFunction-iIncludes[].
    endif.

    if not searchForFunctions is initial.
      perform scanForFunctions using waFunction-functionMainInclude
                                     waFunction-programLinkName
                                     recursiveIncludes
                                     recursiveFunctions
                                     customerOnly
                                     customerNameRange
                                     iLocFunctions[].
    endif.

    modify iLocFunctions from waFunction.
  endloop.

* Now we have everthing perhaps we had better find all the dictionary
* structures
  if not searchForDictionary is initial.
    loop at iLocFunctions into waFunction.
      perform scanForTables using waFunction-progname
                                  customerOnly
                                  customerNameRange
                                  waFunction-iDictStruct[].

      perform scanForLikeOrType using waFunction-progname
                                      customerOnly
                                      customerNameRange
                                      waFunction-iDictStruct[].

      loop at waFunction-iIncludes into waInclude.
        perform scanForTables using waInclude-includeName
                                    customerOnly
                                    customerNameRange
                                    waFunction-iDictStruct[].

        perform scanForLikeOrType using waInclude-includeName
                                        customerOnly
                                        customerNameRange
                                        waFunction-iDictStruct[].
      endloop.

    modify iLocFunctions from waFunction.
    endloop.
  endif.

* Now search for all messages
  if not searchForMessages is initial.
    loop at iLocFunctions into waFunction.
      perform scanForMessages using waFunction-progName
                                    waFunction-messageClass
                                    waFunction-iMessages[].
    modify iLocFunctions from waFunction.
    endloop.
  endif.
endform.
                    "scanForAdditionalFuncStuff

*-----------------------------------------------------------------------
* scanForClasses... Search each class or method for other classes
*-----------------------------------------------------------------------
form scanForClasses using value(className)
                          value(classLinkName)
                          value(customerOnly)
                          value(customerNameRange)
                                iLocClasses like iClasses[].

data iLines type standard table of string with header line.
data: head type string.
data: tail type string.
data: lineLength type i value 0.
data: waLine type string.
data: waClass type tClass.
data: castClassName type program.
data: exceptionCustomerNameRange type string.

* Build the name of the possible cusotmer exception classes
  concatenate customerNameRange 'CX_' into  exceptionCustomerNameRange.

* Read the program code from the textpool.
  castClassName = className.
  read report castClassName into iLines.

  loop at iLines into waLine.
*   Find custom tables.
    lineLength = strLen( waLine ).
    if lineLength > 0.
      if waLine(1) = ASTERIX.
        continue.
      endif.

      translate waLine to upper case.

      find TYPEREFTO in waLine ignoring case.
      if sy-subrc = 0.
*       Have found a reference to another class
        split waLine at TYPE into head tail.
        shift tail left deleting leading space.
        split tail at 'REF' into head tail.
        shift tail left deleting leading space.
        split tail at 'TO' into head tail.
        shift tail left deleting leading space.
        if tail cs PERIOD.
          split tail at PERIOD into head tail.
        else.
          if tail cs COMMA.
            split tail at COMMA into head tail.
          endif.
        endif.
      else.
*   Try and find classes which are only referenced through static mehods
        find '=>' in waLine match offset sy-fdpos.
        if sy-subrc = 0.
          head = waline+0(sy-fdpos).
          shift head left deleting leading space.
          condense head.
          find 'call method' in head ignoring case.
          if sy-subrc = 0.
            shift head left deleting leading space.
            split head at space into head tail.
            split tail at space into head tail.
*           Should have the class name here
            head = tail.
          else.
*        Still have a class name even though it does not have the
*        words call method in front
            if waLine cs '='.
              split waLine at '=' into tail head.
              shift head left deleting leading space.
              split head at '=' into head tail.
            endif.
            sy-subrc = 0.
          endif.
        endif.
      endif.

      if sy-subrc = 0.
        try.
          if head+0(1) = 'Y' or head+0(1) = 'Z' or head cs
customerNameRange.
*           We have found a class best append it to our class table if
* we do not already have it.
            read table iLocClasses into waClass with key clsName = head.
            if sy-subrc <> 0.
              if head+0(3) = 'CX_'
                 or head+0(4) = 'ZCX_'
                 or head+0(4) = 'YCX_'
                 or head cs exceptionCustomerNameRange.

                waClass-exceptionClass = TRUE.
              endif.

              waClass-clsname = head.
              append waClass to iLocClasses.
            endif.
          endif.
          catch cx_sy_range_out_of_bounds.
        endtry.
      endif.
    endif.
  endloop.
endform.
                                "scanForClasses

*-----------------------------------------------------------------------
* scanForIncludePrograms... Search each program for include programs
*-----------------------------------------------------------------------
form scanForIncludePrograms using value(programName)
                                  value(recursiveIncludes)
                                  value(customerOnly)
                                  value(customerNameRange)
                                        iLocIncludes like dumiIncludes[]
.

data: iIncludeLines type standard table of string with header line.
data: iTokens type standard table of stokes with header line.
data: iKeywords type standard table of text20 with header line.
data: iStatements type standard table of sstmnt with header line.
data: waTokens type stokes.
data: waInclude type tInclude.
data: waIncludeExists type tInclude.
data: maxLines type i.
data: nextLine type i.
data: castProgramName type program.

* Read the program code from the textpool.
  castProgramName = programName.
  read report castProgramName into iIncludeLines.

  append INCLUDE to iKeywords.
  scan abap-source iIncludeLines tokens into iTokens with includes
statements into iStatements keywords from iKeywords.

  clear iIncludeLines[].

  maxLines = lines( iTokens ).
  loop at iTokens where str = INCLUDE and type = 'I'.
     nextLine = sy-tabix + 1.
     if nextLine <= maxLines.
       read table iTokens index nextLine into waTokens.

*      Are we only to find customer includes?
       if not customerOnly is initial.
         try.
           if waTokens-str+0(1) = 'Y' or waTokens-str+0(1) = 'Z' or
waTokens-str cs customerNameRange
              or waTokens-str+0(2) = 'MZ' or waTokens-str+0(2) = 'MY'.

           else.
             continue.
           endif.
           catch cx_sy_range_out_of_bounds into objRuntimeError.
         endtry.
       endif.

       waInclude-includeName = waTokens-str.

*      Best find the program title text as well.
       perform findProgramOrIncludeTitle using waInclude-includeName
                                               waInclude-includeTitle.

*      Don't append the include if we already have it listed
       read table iLocIncludes into waIncludeExists with key includeName
 = waInclude-includeName.
       if sy-subrc <> 0.
         append waInclude to iLocIncludes.

         if not recursiveIncludes is initial.
*          Do a recursive search for other includes
           perform scanForIncludePrograms using waInclude-includeName
                                                recursiveIncludes
                                                customerOnly
                                                customerNameRange
                                                iLocIncludes[].
         endif.
       endif.
     endif.
   endloop.
endform.
                        "scanForIncludePrograms

*-----------------------------------------------------------------------
* scanForFunctions... Search each program for function modules
*-----------------------------------------------------------------------
form scanForFunctions using value(programName)
                            value(programLinkName)
                            value(recursiveIncludes)
                            value(recursiveFunctions)
                            value(customerOnly)
                            value(customerNameRange)
                                  iLocFunctions like iFunctions[].

data: iIncludeLines type standard table of string with header line.
data: iTokens type standard table of stokes with header line.
data: iStatements type standard table of sstmnt with header line.
data: waTokens type stokes.
data: waFunction type tFunction.
data: waFunctionComparison type tFunction.
data: maxLines type i.
data: nextLine type i.
data: castProgramName type program.
data: skipThisloop type i.

* Read the program code from the textpool.
  castProgramName = programName.
  read report castProgramName into iIncludeLines.
  scan abap-source iIncludeLines tokens into iTokens with includes
statements into iStatements.
  clear iIncludeLines[].

  maxLines = lines( iTokens ).
  loop at iTokens where str = FUNCTION and type = 'I'.

     nextLine = sy-tabix + 1.
     if nextLine <= maxLines.
       read table iTokens index nextLine into waTokens.

*      Are we only to find customer functions
       skipThisLoop = FALSE.
       if not customerOnly is initial.
         try.
           if waTokens-str+1(1) = 'Y' or waTokens-str+1(1) = 'Z' or
waTokens-str cs customerNameRange.
           else.
             skipThisLoop = TRUE.
           endif.
         catch cx_sy_range_out_of_bounds into objRuntimeError.
         cleanup.
           skipThisLoop = TRUE.
         endtry.
       endif.

       if skipThisLoop = FALSE.
         waFunction-functionName = waTokens-str.
         replace all occurrences of '''' in waFunction-functionName with
 ' '.
         condense waFunction-functionName.

*        Don't add a function if we alread have it listed.
         read table iLocFunctions with key functionName =
 waFunction-functionName into waFunctionComparison.
         if sy-subrc <> 0.
*          Add in the link name if the function is linked to a program
           waFunction-programLinkName = programLinkName.

*          Don't download functions which are called through an RFC
* destination
           nextline = sy-tabix + 2.
           read table iTokens index nextLine into waTokens.
           if waTokens-str <> DESTINATION.

*            Find the function group
             select single area from v_fdir into
wafunction-functionGroup where funcName = waFunction-functionName.

             if sy-subrc = 0.
*              Best find the function number as well.
               perform retrieveFunctionDetail using
waFunction-functionName
                                                    waFunction-progname

waFunction-includeNumber

waFunction-functionTitle.

               perform findMainFunctionInclude using waFunction-progname

waFunction-includeNumber

waFunction-functionMainInclude.

               perform findFunctionTopInclude using waFunction-progname

waFunction-topIncludeName.

*              Find main message class
               perform findMainMessageClass using waFunction-progname

waFunction-messageClass.

               append waFunction to iLocFunctions.

*              Now lets search a little bit deeper and do a recursive
* search for other includes
               if not recursiveIncludes is initial.
                 perform scanForIncludePrograms using
waFunction-functionMainInclude
                                                      recursiveIncludes
                                                      customerOnly
                                                      customerNameRange

waFunction-iIncludes[].
               endif.

*              Now lets search a little bit deeper and do a recursive
* search for other functions
               if not recursiveFunctions is initial.
                 perform scanForFunctions using
waFunction-functionMainInclude
                                                space
                                                recursiveIncludes
                                                recursiveFunctions
                                                customerOnly
                                                customerNameRange
                                                iLocFunctions[].
               endif.
               clear waFunction.
             endif.
           endif.
         endif.

         clear waFunction.
       endif.
     endif.
   endloop.
endform.
                              "scanForFunctions

*-----------------------------------------------------------------------
*  scanForFunctionIncludes... Find all user defined includes within the
*  function group
*-----------------------------------------------------------------------
form scanForFunctionIncludes using poolName
                                   value(customerOnly)
                                   value(customerNameRange)
                                   iLocIncludes like dumiIncludes[].

data: iIncludeLines type standard table of string with header line.
data: iTokens type standard table of stokes with header line.
data: iKeywords type standard table of text20 with header line.
data: iStatements type standard table of sstmnt with header line.
data: waTokens type stokes.
data: waInclude type tInclude.
data: waIncludeExists type tInclude.
data: maxLines type i.
data: nextLine type i.
data: castProgramName type program.

* Read the program code from the textpool.
  castProgramName = poolName.
  read report castProgramName into iIncludeLines.

  append INCLUDE to iKeywords.
  scan abap-source iIncludeLines tokens into iTokens with includes
statements into iStatements keywords from iKeywords.

  clear iIncludeLines[].

  maxLines = lines( iTokens ).
  loop at iTokens where str = INCLUDE and type = 'I'.
     nextLine = sy-tabix + 1.
     if nextLine <= maxLines.
       read table iTokens index nextLine into waTokens.

       if waTokens-str cp '*F++'.
*        Are we only to find customer includes?
         if not customerOnly is initial.
           try.
             if waTokens-str+0(2) = 'LY' or waTokens-str+0(2) = 'LZ' or
waTokens-str cs customerNameRange.
             else.
               continue.
             endif.
             catch cx_sy_range_out_of_bounds into objRuntimeError.
           endtry.
         endif.

         waInclude-includeName = waTokens-str.

*        Best find the program title text as well.
         perform findProgramOrIncludeTitle using waInclude-includeName
                                                 waInclude-includeTitle.

*        Don't append the include if we already have it listed
         read table iLocIncludes into waIncludeExists with key
includeName = waInclude-includeName.
         if sy-subrc <> 0.
           append waInclude to iLocIncludes.
         endif.
       endif.
     endif.
   endloop.
endform.
                       "scanForFunctionIncludes

*-----------------------------------------------------------------------
*  findProgramOrIncludeTitle...   Finds the title text of a program.
*-----------------------------------------------------------------------
form findProgramOrIncludeTitle using value(programName)
                                           titleText.

  select single text
                from trdirt
                into titleText
                where name = programName
                  and sprsl = sy-langu.
endform.
                     "findProgramOrIncludeTitle

*-----------------------------------------------------------------------
* retrievePrograms...    find programs and sub objects from SAP DB
*-----------------------------------------------------------------------
form retrievePrograms using iLocProgram like iPrograms[]
                            iLocFunctions like iFunctions[]
                            rangeProgram like soProgramName[]
                            rangeAuthor like soAuthor[]
                            value(custNameRange)
                            value(alsoModifiedByauthor)
                            value(customerProgsOnly)
                            value(getMessages)
                            value(getTextElements)
                            value(getCustDictStructures)
                            value(getFunctions)
                            value(getIncludes)
                            value(getScreens)
                            value(recursiveFuncSearch)
                            value(recursiveIncludeSearch)
                            value(getLocalObjects)
                            value(package).

data: waRangeProgram like line of rangeProgram.

  if rangeProgram[] is initial.
*   We are finding all programs by an author
    perform findAllProgramsForAuthor using iLocProgram[]
                                           rangeProgram[]
                                           rangeAuthor[]
                                           custNameRange
                                           alsoModifiedByAuthor
                                           customerProgsOnly
                                           getLocalObjects
                                           package.
  else.
    read table rangeProgram index 1 into waRangeProgram.
    if waRangeProgram-low cs ASTERIX.
      perform findProgramsByWildcard using iLocProgram[]
                                           rangeProgram[]
                                           rangeAuthor[]
                                           custNameRange
                                           customerProgsOnly
                                           getLocalObjects
                                           package.
    else.
      perform checkProgramDoesExist using iLocProgram[]
                                          rangeProgram[].
    endif.
  endif.

* Find extra items
  perform scanForAdditionalProgStuff using iLocProgram[]
                                           iLocFunctions[]
                                           getTextElements
                                           getMessages
                                           getScreens
                                           getCustDictStructures
                                           getFunctions
                                           getIncludes
                                           customerProgsOnly
                                           custNameRange
                                           recursiveIncludeSearch
                                           recursiveFuncSearch.
endform.
               "retrievePrograms

*-----------------------------------------------------------------------
*  scanForAdditionalProgStuff...
*-----------------------------------------------------------------------
form scanForAdditionalProgStuff using iLocProgram like iPrograms[]
                                      iLocFunctions like iFunctions[]
                                      value(getTextElements)
                                      value(getMessages)
                                      value(getScreens)
                                      value(getCustDictStructures)
                                      value(getFunctions)
                                      value(getIncludes)
                                      value(customerOnly)
                                      value(customerNameRange)
                                      value(recursiveIncludeSearch)
                                      value(recursiveFuncSearch).

data: waProgram type tProgram.
data: waInclude type tInclude.
data: myTabix type syTabix.

* Best to find all the includes used in a program first
  if not getIncludes is initial.
    loop at iLocProgram into waProgram.
      myTabix = sy-tabix.
      perform scanForIncludePrograms using waProgram-progName
                                           recursiveIncludeSearch
                                           customerOnly
                                           customerNameRange
                                           waProgram-iIncludes[].

      modify iLocProgram from waProgram index myTabix.
    endloop.
  endif.

* Once we have a list of all the includes we need to loop round them an
* select all the other objects
  loop at iLocProgram into waProgram.
    myTabix = sy-tabix.
    perform findProgramDetails using waProgram-progName
                                     waProgram-subc
                                     waProgram-programTitle
                                     waProgram
                                     getTextElements
                                     getMessages
                                     getScreens
                                     getCustDictStructures
                                     customerOnly
                                     customerNameRange.

*   Find any screens
    if not getScreens is initial.
      perform findProgramScreenFlow using waProgram.
    endif.

    loop at waProgram-iIncludes into waInclude.
      perform findProgramDetails using waInclude-includeName
                                       'I'
                                       waInclude-includeTitle
                                       waProgram
                                       getTextElements
                                       getMessages
                                       getScreens
                                       getCustDictStructures
                                       customerOnly
                                       customerNameRange.
    endloop.

    modify iLocProgram from waProgram index myTabix.
  endloop.

* Now we have all the program includes and details we need to find extra
* functions
  if not getFunctions is initial.
    loop at iLocProgram into waProgram.
*     Find any functions defined in the code
      perform scanForFunctions using waProgram-progname
                                     waProgram-progname
                                     space
                                     space
                                     customerOnly
                                     customerNameRange
                                     iLocFunctions[].
    endloop.
  endif.

* We have a list of all the functions so lets go and find details and
* other function calls
  perform scanForAdditionalFuncStuff using iLocFunctions[]
                                           recursiveIncludeSearch
                                           recursiveFuncSearch
                                           getIncludes
                                           getFunctions
                                           getCustDictStructures
                                           getMessages
                                           customerOnly
                                           customerNameRange.
endform.
     "scanForAdditionalProgStuff

*-----------------------------------------------------------------------
*  findProgramDetails...
*-----------------------------------------------------------------------
form findProgramDetails using value(programName)
                              value(programType)
                                    programTitle
                                    waProgram type tProgram
                              value(getTextElements)
                              value(getMessages)
                              value(getScreens)
                              value(getCustDictStructures)
                              value(customerOnly)
                              value(customerNameRange).

  perform findProgramOrIncludeTitle using programName
                                          programTitle.

  if not getTextElements is initial.
*   Find the program texts from out of the database.
    perform retrieveProgramTexts using waProgram-iSelectionTexts[]
                                       waProgram-iTextElements[]
                                       programName.
  endif.

* Search for any GUI texts
  if not getScreens is initial and ( programType = 'M' or programType =
'1' ).
    perform retrieveGUITitles using waProgram-iGUITitle[]
                                    programName.
  endif.

* Find individual messages
  if not getMessages is initial.
    if programType = 'M' or programType = '1'.
      perform findMainMessageClass using programName
                                         waProgram-messageClass.
    endif.

    perform scanForMessages using programName
                                  waProgram-messageClass
                                  waProgram-iMessages[].
  endif.

  if not getCustDictStructures is initial.
    perform scanForTables using programName
                                customerOnly
                                customerNameRange
                                waProgram-iDictStruct[].

    perform scanForLikeOrType using programName
                                    customerOnly
                                    customerNameRange
                                    waProgram-iDictStruct[].
  endif.
endform.
             "findProgramDetails

*-----------------------------------------------------------------------
*  findAllProgramsForAuthor...
*-----------------------------------------------------------------------
form findAllProgramsForAuthor using iLocProgram like iPrograms[]
                                    rangeProgram like soProgramName[]
                                    rangeAuthor like soAuthor[]
                                    value(custNameRange)
                                    value(alsoModifiedByauthor)
                                    value(customerProgsOnly)
                                    value(getLocalObjects)
                                    value(package).

data: altCustomerNameRange type string.
field-symbols: <waProgram> type tProgram.
data: genFlag type genFlag.

* build up the customer name range used for select statements
  concatenate custNameRange '%' into altCustomerNameRange.

* select by name and author
  if not alsoModifiedByAuthor is initial.
*   Programs modified by author
*   Program to search for is an executable program
    if customerProgsOnly is initial.
*     Select all programs
      select progname
             subc
             from reposrc
             appending corresponding fields of table ilocProgram
             where progname in rangeProgram
               and cnam in rangeAuthor
               and ( subc = '1' or subc = 'M' or subc = 'S' ).

    else.
*     Select only customer specific programs
      select progname
             subc
             from reposrc
             appending corresponding fields of table iLocProgram
             where progname  in rangeProgram
               and ( progname like altCustomerNameRange
                     or progname like 'Z%'
                     or progname like 'Y%'
                     or progname like 'SAPMZ%'
                     or progname like 'SAPMY%')
               and cnam in rangeAuthor
               and ( subc = '1' or subc = 'M' or subc = 'S' ).
    endif.
  else.

*   Programs created by author
    if customerProgsOnly is initial.
*     Select all programs
      select progname
             subc
             from reposrc
             appending corresponding fields of table iLocProgram
             where progname in rangeProgram
               and ( subc = '1' or subc = 'M' or subc = 'S' )
               and ( cnam in rangeAuthor or unam in rangeAuthor ).
    else.
*     Select only customer specific programs
      select progname
             subc
             from reposrc
             appending corresponding fields of table iLocProgram
             where progname in rangeProgram
               and ( progname like altCustomerNameRange
                     or progname like 'Z%'
                     or progname like 'Y%'
                     or progname like 'SAPMZ%'
                     or progname like 'SAPMY%')
               and ( subc = '1' or subc = 'M' or subc = 'S' )
               and ( cnam in rangeAuthor or unam in rangeAuthor ).
    endif.
  endif.

* Delete any programs which are local objects
  if getLocalObjects is initial.
    loop at iLocProgram assigning <waProgram>.
      select single genflag
                    from tadiv
                    into genflag
                    where pgmid = 'R3TR'
                      and object = 'PROG'
                      and obj_name = <waProgram>-progName
                      and devclass = '$TMP'.
      if sy-subrc = 0.
        delete iLocProgram.
      endif.
    endloop.
  endif.

* Delete any programs which are not in the specified package
  if not package is initial.
    if package cs '*'.
      translate package using '*%'.
    endif.

    loop at iLocProgram assigning <waProgram>.
      select single genflag
                    from tadiv
                    into genflag
                    where pgmid = 'R3TR'
                      and object = 'PROG'
                      and obj_name = <waProgram>-progName
                      and devclass like package.
      if sy-subrc <> 0.
        delete iLocProgram.
      endif.
    endloop.
  endif.
endform.
       "findAllProgramsForAuthor

*-----------------------------------------------------------------------
*  checkProgramDoesExist...
*-----------------------------------------------------------------------
form checkProgramDoesExist using iLocProgram like iPrograms[]
                                 rangeProgram like soProgramName[].

data: waProgram type tProgram.

*  Check to see if the program is an executable program
   select single progname
                 subc
                 into (waProgram-progname, waProgram-subc)
                 from reposrc
                 where progname in rangeProgram
                   and ( subc = '1' or
                         subc = 'I' or
                         subc = 'M' or
                         subc = 'S' ).

   if not waProgram-progname is initial.
     append waProgram to iLocProgram.
   endif.
endform.
          "checkProgramDoesExist

*-----------------------------------------------------------------------
*  findProgramsByWildcard.. Search in the system for programs
*-----------------------------------------------------------------------
form findProgramsByWildcard using iLocProgram like iPrograms[]
                                  value(rangeProgram) like
soProgramName[]
                                  value(rangeAuthor) like soAuthor[]
                                  value(custNameRange)
                                  value(customerProgsOnly)
                                  value(getLocalObjects)
                                  value(package).

data: altCustomerNameRange type string.
field-symbols: <waProgram> type tProgram.
data: genFlag type genFlag.

  if customerProgsOnly is initial.
*   build up the customer name range used for select statements
    if custNameRange <> '^'.
      concatenate custNameRange '%' into altCustomerNameRange.

      select progname
             subc
             from reposrc
             appending corresponding fields of table iLocProgram
             where progname  in rangeProgram
               and progname like altCustomerNameRange
               and ( subc = '1' or subc = 'M' or subc = 'S' )
               and ( cnam in rangeAuthor or unam in rangeAuthor ).
    else.
      select progname
             subc
             from reposrc
             appending corresponding fields of table iLocProgram
             where progname  in rangeProgram
               and ( subc = '1' or subc = 'M' or subc = 'S' )
               and ( cnam in rangeAuthor or unam in rangeAuthor ).
    endif.
  else.
*   Only customer programs
    if custNameRange <> '^'.
      concatenate custNameRange '%' into altCustomerNameRange.

      select progname
             subc
             from reposrc
             appending corresponding fields of table iLocProgram
             where progname  in rangeProgram
               and ( progname like altCustomerNameRange
                     or progname like 'Z%'
                     or progname like 'Y%'
                     or progname like 'SAPMZ%'
                     or progname like 'SAPMY%')
               and ( subc = '1' or subc = 'M' or subc = 'S' )
               and ( cnam in rangeAuthor or unam in rangeAuthor ).
    else.
      select progname
             subc
             from reposrc
             appending corresponding fields of table iLocProgram
             where progname  in rangeProgram
             and ( progname like 'Z%'
                   or progname like 'Y%'
                   or progname like 'SAPMZ%'
                   or progname like 'SAPMY%')
             and ( subc = '1' or subc = 'M' or subc = 'S' )
             and ( cnam in rangeAuthor or unam in rangeAuthor ).
    endif.
  endif.

* Delete any programs which are local objects
  if getLocalObjects is initial.
    loop at iLocProgram assigning <waProgram>.
      select single genflag
                    from tadiv
                    into genflag
                    where pgmid = 'R3TR'
                      and object = 'PROG'
                      and obj_name = <waProgram>-progName
                      and devclass = '$TMP'.
      if sy-subrc = 0.
        delete iLocProgram.
      endif.
    endloop.
  endif.

* Delete any programs which are not in the specified package
  if not package is initial.
    loop at iLocProgram assigning <waProgram>.
      select single genflag
                    from tadiv
                    into genflag
                    where pgmid = 'R3TR'
                      and object = 'PROG'
                      and obj_name = <waProgram>-progName
                      and devclass <> package.
      if sy-subrc = 0.
        delete iLocProgram.
      endif.
    endloop.
  endif.
endform.
         "findProgramsByWildcard

*-----------------------------------------------------------------------
*  retrieveProgramTexts... Find the text elements and selection texts
*  for a program
*-----------------------------------------------------------------------
form retrieveProgramTexts using iLocSelectionTexts like dumiTextTab[]
                                iLocTextElements like dumiTextTab[]
                                value(programName).

data: iTextTable type standard table of tTextTable with header line.
data: waTexts type tTextTable.
data: castProgramName(50).

  move programName to castProgramName.

  read textpool castProgramName into iTextTable language sy-langu.
  delete iTextTable where key = 'R'.

* Selection texts.
  loop at iTextTable where id = 'S'.
    move iTextTable-key to waTexts-key.
    move iTextTable-entry to waTexts-entry.
    append waTexts to iLocSelectiontexts.
    clear waTexts.
  endloop.

* Text elements.
  delete iTextTable where key = 'S'.
  loop at iTextTable where id = 'I'.
    move iTextTable-key to waTexts-key.
    move iTextTable-entry to waTexts-entry.
    append waTexts to iLocTextElements.
  endloop.
endform.
           "retrieveProgramTexts

*-----------------------------------------------------------------------
*  retrieveGUITitles...  Search for any GUI texts
*-----------------------------------------------------------------------
form retrieveGUITitles using iLocGUITitle like dumIGUITitle[]
                             value(programName).

  select obj_code
         text
         from d347t
         appending corresponding fields of table iLocGUItitle
         where progname = programName.
endform.
              "retrieveGUITitles

*-----------------------------------------------------------------------
*   findMainMessageClass... find the message class stated at the top of
*   program.
*-----------------------------------------------------------------------
form findMainMessageClass using value(programName)
                                      messageClass.

  select single msgid
                from trdire into messageClass
                where report = programName.
endform.
           "findMainMessageClass

*-----------------------------------------------------------------------
* retrieveClasses...    find classes and sub objects from SAP DB
*-----------------------------------------------------------------------
form retrieveClasses using iLocClasses like iClasses[]
                           iLocFunctions like iFunctions[]
                           rangeClass like soClassName[]
                           rangeAuthor like soAuthor[]
                           value(custNameRange)
                           value(alsoModifiedByauthor)
                           value(customerProgsOnly)
                           value(getMessages)
                           value(getTextElements)
                           value(getCustDictStructures)
                           value(getFunctions)
                           value(getIncludes)
                           value(recursiveFuncSearch)
                           value(recursiveIncludeSearch)
                           value(recursiveClassSearch)
                           value(language).

data: waRangeClass like line of rangeClass.

  if rangeClass[] is initial.
*   We are finding all programs by an author
    perform findAllClassesForAuthor using iLocClasses[]
                                           rangeClass[]
                                           rangeAuthor[]
                                           custNameRange
                                           alsoModifiedByAuthor
                                           customerProgsOnly
                                           language.
  else.
    read table rangeClass index 1 into waRangeClass.
    if waRangeClass-low cs ASTERIX.
      perform findClassesByWildcard using iLocClasses[]
                                          rangeClass[]
                                          rangeAuthor[]
                                          custNameRange
                                          customerProgsOnly
                                          language.
    else.
      perform checkClassDoesExist using iLocClasses[]
                                        rangeClass[].
    endif.
  endif.

* Find extra items
  if not iLocClasses[] is initial.
    perform scanForAdditionalClassStuff using iLocClasses[]
                                              iLocFunctions[]
                                              getTextElements
                                              getMessages
                                              getCustDictStructures
                                              getFunctions
                                              getIncludes
                                              customerProgsOnly
                                              custNameRange
                                              recursiveIncludeSearch
                                              recursiveFuncSearch
                                              recursiveClassSearch.
  endif.
endform.
                "retrieveClasses

*-----------------------------------------------------------------------
*  findAllClassesForAuthor...
*-----------------------------------------------------------------------
form findAllClassesForAuthor using iLocClass like iClasses[]
                                   rangeClass like soClassName[]
                                   rangeAuthor like soAuthor[]
                                   value(custNameRange)
                                   value(alsoModifiedByauthor)
                                   value(customerClassesOnly)
                                   value(language).

data: altCustomerNameRange(2).

* build up the customer name range used for select statements
  concatenate custNameRange '%' into altCustomerNameRange.

* select by name and author
  if not alsoModifiedByAuthor is initial.
*   Classes modified by author
    if customerClassesOnly is initial.
*     Select all classes
      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and langu = language
               and ( author in rangeAuthor or changedby in rangeAuthor )
               and version = '1'
               and ( state = '0' or state = '1' ).

      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
               and langu = language
                 and ( author in rangeAuthor or changedby in rangeAuthor
 )
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    else.
*     Select only customer specific classes
      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and ( clsname like altCustomerNameRange
                     or clsname like 'Z%'
                     or clsname like 'Y%')
               and langu = language
               and ( author in rangeAuthor or changedby in rangeAuthor )
               and version = '1'
               and ( state = '0' or state = '1' ).

      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and ( clsname like altCustomerNameRange
                       or clsname like 'Z%'
                       or clsname like 'Y%')
                 and langu = language
                 and ( author in rangeAuthor or changedby in rangeAuthor
 )
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    endif.
  else.
*   Programs created by author
    if customerClassesOnly is initial.
*     Select all classes
      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and langu = language
               and author in rangeAuthor
               and version = '1'
               and ( state = '0' or state = '1' ).

      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and langu = language
                 and author in rangeAuthor
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    else.
*     Select only customer specific classes
      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and ( clsname like altCustomerNameRange
                     or clsname like 'Z%'
                     or clsname like 'Y%')
               and langu = language
               and author in rangeAuthor
               and version = '1'
               and ( state = '0' or state = '1' ).

      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and ( clsname like altCustomerNameRange
                       or clsname like 'Z%'
                       or clsname like 'Y%')
                 and langu = language
                 and author in rangeAuthor
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    endif.
  endif.
endform.
        "findAllClassesForAuthor

*-----------------------------------------------------------------------
*  findClassesByWildcard...  Find classes using a wildcard search
*-----------------------------------------------------------------------
form findClassesByWildcard using iLocClass like iClasses[]
                                 rangeClass like soClassName[]
                                 value(rangeAuthor) like soAuthor[]
                                 value(custNameRange)
                                 value(customerClassesOnly)
                                 value(language).

data: altCustomerNameRange(2).

  if customerClassesOnly is initial.
*   Searching for customer and SAP classes
    if custNameRange <> '^'.
*     build up the customer name range used for select statements
      concatenate custNameRange '%' into altCustomerNameRange.

      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and clsname like custNameRange
               and langu = language
               and ( author in rangeAuthor or changedby in rangeAuthor )
               and version = '1'
               and ( state = '0' or state = '1' ).
      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and clsname like custNameRange
                 and langu = language
                 and ( author in rangeAuthor or changedby in rangeAuthor
 )
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    else.
*     Searching using normal name ranges
      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and langu = language
               and ( author in rangeAuthor or changedby in rangeAuthor )
               and version = '1'
               and ( state = '0' or state = '1' ).
      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and langu = language
                 and ( author in rangeAuthor or changedby in rangeAuthor
 )
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    endif.
  else.
*   searching for only customer classes
    if custNameRange <> '^'.
*     build up the customer name range used for select statements
      concatenate custNameRange '%' into altCustomerNameRange.

      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and clsname like custNameRange
               and langu = language
               and ( clsname like 'ZC%' or clsname like 'YC%' )
               and ( author in rangeAuthor or changedby in rangeAuthor )
               and version = '1'
               and ( state = '0' or state = '1' ).
      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and langu = language
                 and ( clsname like 'ZC%' or clsname like 'YC%' )
                 and ( author in rangeAuthor or changedby in rangeAuthor
 )
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    else.
*     Searching using normal name ranges
      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and ( clsname like 'ZC%' or clsname like 'YC%' )
               and ( author in rangeAuthor or changedby in rangeAuthor )
               and version = '1'
               and ( state = '0' or state = '1' ).
      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and ( clsname like 'ZC%' or clsname like 'YC%' )
                 and ( author in rangeAuthor or changedby in rangeAuthor
 )
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    endif.
  endif.
endform.
          "findClassesByWildcard

*-----------------------------------------------------------------------
*  checkClassDoesExist...
*-----------------------------------------------------------------------
form checkClassDoesExist using iLocClass like iClasses[]
                               rangeClass like soClassName[].

data: waClass type tClass.

  select single clsname descript msg_id
         from vseoclass
         into corresponding fields of waClass
         where clsname in rangeClass
           and version = '1'
           and ( state = '0' or state = '1' ).

  if sy-subrc <> 0.
    select single clsname descript msg_id
         from vseoclass
         into corresponding fields of waClass
         where clsname in rangeClass
           and version = '0'
           and ( state = '0' or state = '1' ).
  endif.

   if not waClass-clsname is initial.
     append waClass to iLocClass.
   endif.
endform.
            "checkClassDoesExist

*-----------------------------------------------------------------------
*  scanForAdditionalClassStuff...
*-----------------------------------------------------------------------
form scanForAdditionalClassStuff using iLocClasses like iClasses[]
                                       iLocFunctions like iFunctions[]
                                       value(getTextElements)
                                       value(getMessages)
                                       value(getCustDictStructures)
                                       value(getFunctions)
                                       value(getIncludes)
                                       value(customerOnly)
                                       value(customerNameRange)
                                       value(recursiveIncludeSearch)
                                       value(recursiveFuncSearch)
                                       value(recursiveClassSearch).

data: waClass type tClass.
data: waMethod type tMethod.
data: myTabix type syTabix.
data: scanningForClasses type i value FALSE.
data: classNewLines type i value 0.
data: classCurrentLines type i value 0.

  loop at iLocClasses into waClass where scanned is initial.
*  Once we have a list of all the classes we need to loop round them an
*  select all the other objects
    myTabix = sy-tabix.
    perform findClassDetails using waClass-clsName
                                   waClass
                                   iLocFunctions[]
                                   getTextElements
                                   getMessages
                                   getFunctions
                                   getCustDictStructures
                                   customerOnly
                                   customerNameRange.

*   Set the scanned class so we do not check them again when running
*   recursively.
    waClass-scanned = 'X'.
    modify iLocClasses from waClass index myTabix.
  endloop.

* Now we have all the classes and details we need to find extra classes
  if not recursiveClassSearch is initial.
    classCurrentLines = lines( iLocClasses ).
    loop at iLocClasses into waClass.
*     Don't try and find any other details for an exception class
      if ( waClass-clsName ns 'ZCX_' or waClass-clsName ns 'CX_'  ).
*       Find any classes defined in the main class definition
        perform scanForClasses using waClass-privateClassKey
                                     waClass-clsname
                                     customerOnly
                                     customerNameRange
                                     iLocClasses[].

        perform scanForClasses using waClass-publicClassKey
                                     waClass-clsname
                                     customerOnly
                                     customerNameRange
                                     iLocClasses[].

        perform scanForClasses using waClass-protectedClassKey
                                     waClass-clsname
                                     customerOnly
                                     customerNameRange
                                     iLocClasses[].

        loop at waClass-iMethods into waMethod.
*         Find any classes defined in any of the methods
          perform scanForClasses using waMethod-methodKey
                                       waClass-clsname
                                       customerOnly
                                       customerNameRange
                                       iLocClasses[].
        endloop.
      endif.
    endloop.

*   We have a list of all the classes so lets go and find their details
    classNewLines = lines( iLocClasses ).
    if classNewLines > classCurrentLines.
      perform scanForAdditionalClassStuff using iLocClasses[]
                                                iLocFunctions[]
                                                getTextElements
                                                getMessages
                                                getCustDictStructures
                                                getFunctions
                                                getIncludes
                                                customerOnly
                                                customerNameRange
                                                recursiveIncludeSearch
                                                recursiveFuncSearch
                                                recursiveClassSearch.
    endif.
  endif.
endform.
   "scanForAdditionalClassStuff

*-----------------------------------------------------------------------
*  findClassDetails...
*-----------------------------------------------------------------------
form findClassDetails using value(className)
                                  waClass type tClass
                              iLocFunctions like iFunctions[]
                              value(getTextElements)
                              value(getMessages)
                              value(getFunctions)
                              value(getCustDictStructures)
                              value(customerOnly)
                              value(customerNameRange).

data: iEmptySelectionTexts type standard table of tTextTable.
data: myTabix type syTabix.
data: waMethod type tMethod.

* Build up the keys we will use for finding data
  perform buildClassKeys using waClass.

  if waClass-descript is initial.
    perform findClassDescription using className
                                       waClass-descript.
  endif.

* Find the class attributes.
  select single exposure msg_id state clsfinal r3release
                from vseoclass
                into (waClass-exposure, waClass-msg_id, waClass-state,
                      waClass-clsfinal, waClass-r3release)
                where clsName = waClass-clsName.

* Don't try and find any other details for an exception class
  if ( waClass-clsName cs 'ZCX_' or waClass-clsName cs 'CX_'  ).
*   Exception texts
    perform findExceptionTexts using waClass-publicClassKey
                                     waClass-iConcepts[].
    waClass-scanned = 'X'.
  else.
    if not getTextElements is initial.
*     Find the class texts from out of the database.
      perform retrieveProgramTexts using iEmptySelectionTexts[]
                                         waClass-iTextElements[]
                                         waClass-textElementKey.
    endif.

*   Find any declared dictionary structures
    if not getCustDictStructures is initial.
      perform scanForTables using waClass-privateClassKey
                                  customerOnly
                                  customerNameRange
                                  waClass-iDictStruct[].

      perform scanForTables using waClass-publicClassKey
                                  customerOnly
                                  customerNameRange
                                  waClass-iDictStruct[].

      perform scanForTables using waClass-protectedClassKey
                                  customerOnly
                                  customerNameRange
                                  waClass-iDictStruct[].

      perform scanForTables using waClass-typesClassKey
                                  customerOnly
                                  customerNameRange
                                  waClass-iDictStruct[].

      perform scanForLikeOrType using waClass-privateClassKey
                                      customerOnly
                                      customerNameRange
                                      waClass-iDictStruct[].

      perform scanForLikeOrType using waClass-publicClassKey
                                      customerOnly
                                      customerNameRange
                                      waClass-iDictStruct[].

      perform scanForLikeOrType using waClass-protectedClassKey
                                      customerOnly
                                      customerNameRange
                                      waClass-iDictStruct[].

      perform scanForLikeOrType using waClass-typesClassKey
                                      customerOnly
                                      customerNameRange
                                      waClass-iDictStruct[].
    endif.


*   Methods
*   Find all the methods for this class
    perform findClassMethods using className
                                   waClass-iMethods[].

    loop at waClass-iMethods[] into waMethod.
      myTabix = sy-tabix.
*     Find individual messages
      if not getMessages is initial.
        perform scanForMessages using waMethod-methodKey
                                      waClass-msg_id
                                      waClass-iMessages[].
      endif.

      if not getCustDictStructures is initial.
*       Find any declared dictionary structures
        perform scanForTables using waMethod-methodKey
                                    customerOnly
                                    customerNameRange
                                    waClass-iDictStruct[].

        perform scanForLikeOrType using waMethod-methodKey
                                        customerOnly
                                        customerNameRange
                                        waClass-iDictStruct[].
      endif.

      if not getfunctions is initial.
        perform scanForFunctions using waMethod-methodKey
                                       waClass-clsName
                                       space
                                       space
                                       customerOnly
                                       customerNameRange
                                       iLocFunctions[].
      endif.

      modify waClass-iMethods from waMethod index myTabix.
    endloop.
  endif.
endform.
               "findClassDetails

*-----------------------------------------------------------------------
*  buildClassKeys...   Finds the title text of a class.
*-----------------------------------------------------------------------
form buildClassKeys using waClass type tClass.

data: classNameLength type i.
data: loops type i.

  classNameLength = strlen( waClass-clsName ).

  cl_oo_classname_service=>get_pubsec_name( exporting clsname =
waClass-clsName
                                            receiving result =
waClass-publicClassKey ).

  cl_oo_classname_service=>get_prisec_name( exporting clsname =
waClass-clsName
                                            receiving result =
waClass-privateClassKey ).

  cl_oo_classname_service=>get_prosec_name( exporting clsname =
waClass-clsName
                                            receiving result =
waClass-protectedClassKey ).


* Text element key - length of text element key has to be 32 characters.
  loops = 30 - classNameLength.
  waClass-textElementKey = waClass-clsName.
  do loops times.
    concatenate waClass-textElementKey '=' into waClass-textElementKey.
  enddo.
* Save this for later.
  concatenate waClass-textElementKey 'CP' into waClass-textElementKey.

* Types Class key - length of class name has to be 32 characters.
  loops = 30 - classNameLength.
  waClass-typesClassKey = waClass-clsName.
  do loops times.
    concatenate waClass-typesClassKey '=' into waClass-typesClassKey.
  enddo.
* Save this for later
  concatenate waClass-typesClassKey 'CT' into waClass-typesClassKey.
endform.
                 "buildClassKeys

*-----------------------------------------------------------------------
*  findClassDescription...   Finds the title text of a class.
*-----------------------------------------------------------------------
form findClassDescription using value(className)
                                      titleText.

  select single descript
                from vseoclass
                into titleText
                where clsname = className
                  and langu = sy-langu.
  if sy-subrc <> 0.
    select single descript
                  from vseoclass
                  into titleText
                  where clsname = className.
  endif.
endform.
           "findClassDescription

*-----------------------------------------------------------------------
*  findExceptionTexts...   Fiond the texts of an exception class.
*-----------------------------------------------------------------------
form findExceptionTexts using publicClassKey
                              iConcepts like dumiConcepts[].

data: castClassName type program.
data: iTempLines type standard table of string with header line.
data: iTokens type standard table of stokes with header line.
data: iKeywords type standard table of text20 with header line.
data: iStatements type standard table of sstmnt with header line.
data: waTokens type stokes.
data: waCurrentToken type stokes.
data: waConcept like line of iConcepts.
data: tokenLength type i.
data: myRow type i.

  castClassName = publicClassKey.
  read report castClassName into iTempLines.

  append 'CONSTANTS' to iKeywords.
  scan abap-source iTempLines tokens into iTokens statements into
iStatements keywords from iKeywords.

  delete iTokens where str = 'CONSTANTS'.
  delete iTokens where str = 'VALUE'.
  delete iTokens where str = 'TYPE'.

  loop at iTokens into waTokens where str = 'SOTR_CONC'.
*   The loop before holds the constant name
    myRow = sy-tabix - 1.
    read table iTokens index myRow into waCurrentToken.
    waConcept-constName = waCurrentToken-str.

*   The loop after holds the constant name
    myRow = myRow + 2.
    read table iTokens index myRow into waCurrentToken.
    tokenLength = strLen( waCurrentToken-str ).
    if tokenLength = 34.
*     Most likely an exception text.
      replace all occurrences of '''' in waCurrentToken-str with ' ' .
      waConcept-concept = waCurrentToken-str.
      append waConcept to iConcepts.
    endif.
  endloop.
endform.

*-----------------------------------------------------------------------
*  findClassMethods...   Finds the methods of a class.
*-----------------------------------------------------------------------
form findClassMethods using value(className)
                            iLocMethods like dumiMethods[].

data: iMethods type standard table of tMethod with header line.

  select cmpName descript exposure
         from vseomethod
         into corresponding fields of table iMethods
           where clsname = className
             and version = '1'
             and langu = sy-langu
             and ( state = '0' or state = '1' ).

  if sy-subrc <> 0.
    select cmpName descript exposure
           from vseomethod
           into corresponding fields of table iMethods
           where clsname = className
             and version = '0'
             and langu = sy-langu
             and ( state = '0' or state = '1' ).
  endif.

* Find the method key so that we can acces the source code later
  loop at iMethods.
    perform findMethodKey using className
                                iMethods-cmpName
                                iMethods-methodKey.
    modify iMethods.
  endloop.

  iLocMethods[] = iMethods[].
endform.
               "findClassMethods

*-----------------------------------------------------------------------
* findMethodKey... find the unique key which identifes this method
*-----------------------------------------------------------------------
form findMethodKey using value(className)
                         value(methodName)
                               methodKey.

data: methodID type seocpdkey.
data: locMethodKey type program.

  methodID-clsname = className.
  methodID-cpdName = methodName.

  cl_oo_classname_service=>get_method_include( exporting mtdkey =
methodID
                                               receiving result =
locMethodKey
                                               exceptions
 class_not_existing = 1

 method_not_existing = 2 ).

  methodKey = locMethodKey.
endform.
                  "findMethodKey

*-----------------------------------------------------------------------
* scanForMessages... Search each program for messages
*-----------------------------------------------------------------------
form scanForMessages using value(programName)
                           value(mainMessageClass)
                                 iLocMessages like iMessages[].

data: iIncludeLines type standard table of string with header line.
data: iTokens type standard table of stokes with header line.
data: iStatements type standard table of sstmnt with header line.
data: iKeywords type standard table of text20 with header line.
data: waMessage type tMessage.
data: waMessageComparison type tMessage.
data: watokens type stokes.
data: nextLine type i.
data: stringLength type i value 0.
data: workingOnMessage type i value FALSE.
data: castProgramName type program.

* Read the program code from the textpool.
  castProgramName = programName.
  read report castProgramName into iIncludeLines.

  append MESSAGE to iKeywords.
  scan abap-source iIncludeLines tokens into iTokens with includes
statements into iStatements keywords from iKeywords.

  clear iIncludeLines[].

  loop at iTokens.
    if iTokens-str = MESSAGE.
      workingOnMessage = TRUE.
      continue.
    endif.

    if workingOnMessage = TRUE.
      stringLength = strlen( iTokens-str ).

*     Message declaration 1
      if stringLength = 4 and iTokens-str+0(1) ca sy-abcde.
        waMessage-msgnr = iTokens-str+1(3).
        waMessage-arbgb = mainMessageClass.
      else.
        if iTokens-str cs '''' or iTokens-str cs '`'.
*         Message declaration 2
          translate iTokens-str using ''' '.
          translate iTokens-str using '` '.
          condense iTokens-str.
          shift iTokens-str left deleting leading space.
          waMessage-text = iTokens-str.
          waMessage-arbgb = 'Hard coded'.
        else.
          if iTokens-str = 'ID'.
*           Message declaration 3
            nextLine = sy-tabix + 1.
            read table iTokens index nextLine into waTokens.
            translate waTokens-str using ''' '.
            condense iTokens-str.
            shift waTokens-str left deleting leading space.
            if not waTokens-str = 'SY-MSGID'.
              waMessage-arbgb = waTokens-str.

              nextLine = nextLine + 4.
              read table iTokens index nextLine into waTokens.
              translate waTokens-str using ''' '.
              condense waTokens-str.
              shift waTokens-str left deleting leading space.
              waMessage-msgnr = waTokens-str.
            else.
              workingOnMessage = FALSE.
            endif.
          else.
            if stringLength >= 5 and iTokens-str+4(1) = '('.
*              Message declaration 4
               waMessage-msgnr = iTokens-str+1(3).
               shift iTokens-str left up to '('.
               replace '(' into iTokens-str with space.
               replace ')' into iTokens-str with space.
               condense iTokens-str.
               waMessage-arbgb = iTokens-str.
            endif.
          endif.
        endif.
      endif.

*      find the message text
       if not waMessage-arbgb is initial and not waMessage-msgnr is
initial and waMessage-text is initial.
         select single text
                       from t100
                       into waMessage-text
                       where sprsl = sy-langu
                         and arbgb = waMessage-arbgb
                         and msgnr = waMessage-msgnr.
       endif.

*      Append the message
       if not waMessage is initial.
*        Don't append the message if we already have it listed
         read table iLocMessages with key arbgb = waMessage-arbgb
                                          msgnr = waMessage-msgnr
                                          into waMessageComparison.
         if sy-subrc <> 0.
           append waMessage to iLocMessages.
         endif.
         clear waMessage.
         workingOnMessage = FALSE.
       endif.
     endif.
   endloop.
endform.
                 "scanForMessages

*-----------------------------------------------------------------------
* scanForTables... Search each program for dictionary tables
*-----------------------------------------------------------------------
form scanForTables using value(programName)
                         value(customerOnly)
                         value(customerNameRange)
                               iLocDictionary like iDictionary[].

data: iIncludeLines type standard table of string with header line.
data: iTokens type standard table of stokes with header line.
data: iStatements type standard table of sstmnt with header line.
data: iKeywords type standard table of text20 with header line.
data: waDictionary type tDictTable.
data: waDictionaryComparison type tDictTable.
data: castProgramName type program.

* Read the program code from the textpool.
  castProgramName = programName.
  read report castProgramName into iIncludeLines.

  append TABLES to iKeywords.

  scan abap-source iIncludeLines tokens into iTokens with includes
statements into iStatements keywords from iKeywords.
  clear iIncludeLines[].

  sort iTokens ascending by str.
  delete iTokens where str = TABLES.

  loop at iTokens.
    if not CustomerOnly is initial.
      try.
        if ( iTokens-str+0(1) <> 'Y' or iTokens-str+0(1) <> 'Z' or
iTokens-str ns customerNameRange ).
          continue.
        endif.
      catch cx_sy_range_out_of_bounds into objRuntimeError.
      endtry.
    endif.

    waDictionary-tablename = iTokens-str.
*   Don't append the object if we already have it listed
    read table iLocDictionary into waDictionaryComparison with key
tablename = waDictionary-tableName.
    if sy-subrc <> 0.
      perform findTableDescription using waDictionary-tablename
                                         waDictionary-tableTitle.

      perform findTableDefinition using waDictionary-tableName
                                        waDictionary-iStructure[].

      append waDictionary to iLocDictionary.
    endif.
  endloop.
endform.
                 "scanForTables

*-----------------------------------------------------------------------
*  findProgramScreenFlow...
*-----------------------------------------------------------------------
form findProgramScreenFlow using waProgram type tProgram.

data: iFlow type standard table of tScreenFlow with header line.

  call function 'DYNPRO_PROCESSINGLOGIC'
       exporting
            rep_name  = waProgram-progname
       tables
            scr_logic = iFlow.

  sort iFlow ascending by screen.
  delete adjacent duplicates from iFlow comparing screen.
  if waProgram-subc <> 'M'.
    delete iFlow where screen >= '1000' and screen <= '1099'.
  endif.

  loop at iFlow.
    append iFlow to waProgram-iScreenFlow.
  endloop.
endform.
          "findProgramScreenFlow

*-----------------------------------------------------------------------
*  findFunctionScreenFlow...
*-----------------------------------------------------------------------
form findFunctionScreenFlow using waFunction type tFunction.

data: iFlow type standard table of tScreenFlow with header line.

  call function 'DYNPRO_PROCESSINGLOGIC'
       exporting
            REP_NAME  = waFunction-progName
       tables
            SCR_LOGIC = iFlow.

  sort iFlow ascending by screen.
  delete adjacent duplicates from iFlow comparing screen.

  loop at iFlow.
    append iFlow to waFunction-iScreenFlow.
  endloop.
endform.
          "findFunctionScreenFlow

*-----------------------------------------------------------------------
* scanForLikeOrType... Look for any dictionary objects referenced by a
* like or type statement
*-----------------------------------------------------------------------
form scanForLikeOrType using value(programName)
                             value(customerOnly)
                             value(customerNameRange)
                             iLocDictionary like iDictionary[].

data iLines type standard table of string with header line.
data: head type string.
data: tail type string.
data: junk type string.
data: lineType type string.
data: lineLength type i value 0.
data: endOfLine type i value TRUE.
data: waDictionary type tDictTable.
data: waDictionaryComparison type tDictTable.
data: waLine type string.
data: castProgramName type program.

* Read the program code from the textpool.
  castProgramName = programName.
  read report castProgramName into iLines.

  loop at iLines into waLine.
*   Find custom tables.
    lineLength = strLen( waLine ).
    if lineLength > 0.
      if waLine(1) = ASTERIX.
        continue.
      endif.

      translate waLine to upper case.

*   Determine the lineType.
      if endOfLine = TRUE.
        shift waLine up to LIKE.
        if sy-subrc = 0.
          lineType = LIKE.
        else.
          shift waLine up to TYPE.
          if sy-subrc = 0.
            find 'BEGIN OF' in waLine.
            if sy-subrc <> 0.
              find 'END OF' in waLine.
              if sy-subrc <> 0.
                find 'VALUE' in waLine.
                if sy-subrc <> 0.
                  lineType = TYPE.
                endif.
              endif.
            endif.
          else.
            shift waLine up to INCLUDE.
            if sy-subrc = 0.
              split waLine at space into junk iLines.
            endif.

            shift waLine up to STRUCTURE.
            if sy-subrc = 0.
              lineType = STRUCTURE.
            else.
              continue.
            endif.
          endif.
        endif.
      else.
        lineType = COMMA.
      endif.

      case linetype.
        when LIKE or TYPE or STRUCTURE.
*         Work on the appropriate lineType
          shift waLine up to space.
          shift waLine left deleting leading space.
          if waLine cs TABLE.
            split waLine at TABLE into head tail.
            split tail at 'OF' into head tail.
            waLine = tail.
            shift waLine left deleting leading space.
          endif.

*         Are we only to download SAP dictionary structures.
          if not CustomerOnly is initial.
            try.
              if waLine+0(1) = 'Y' or waLine+0(1) = 'Z' or waLine cs
customerNameRange.
              else.
                lineType = ''.
                continue.
              endif.
              catch cx_sy_range_out_of_bounds into objRuntimeError.
            endtry.
          endif.

          if waLine cs COMMA.
            split waLine at COMMA into head tail.
            if waLine cs DASH.
              split head at DASH into head tail.
            endif.
            if waLine cs OCCURS.
              split waLine at SPACE into head tail.
            endif.
          else.
            if waLine cs PERIOD.
              split waLine at PERIOD into head tail.
              if waLine cs DASH.
                split head at DASH into head tail.
              endif.
              if waLine cs OCCURS.
                split waLine at SPACE into head tail.
              endif.
            else.
              split waLine at SPACE into head tail.
              if waLine cs DASH.
                split head at DASH into head tail.
              endif.
            endif.
          endif.

          if not head is initial.
            waDictionary-tableName = head.
*           Don't append the object if we already have it listed
            read table iLocDictionary into waDictionaryComparison
                                      with key tablename =
waDictionary-tableName.
            if sy-subrc <> 0.
              perform findTableDescription using waDictionary-tablename
                                                 waDictionary-tableTitle
.

              perform findTableDefinition using waDictionary-tableName

waDictionary-iStructure[].

*             Only append if the item is a table and not a structure or
* data element
              if not waDictionary-iStructure[] is initial.
                append waDictionary to iLocDictionary.
              endif.
            endif.
            clear waDictionary.
          endif.

          lineType = ''.
      endcase.
    endif.
  endloop.
endform.
              "scanForLikeOrType

*-----------------------------------------------------------------------
*  displayStatus...
*-----------------------------------------------------------------------
form displayStatus using value(message)
                         value(delay).

  call function 'SAPGUI_PROGRESS_INDICATOR'
       exporting
            percentage = 0
            text       = message
       exceptions
            others     = 1.

  if delay > 0.
    wait up to delay seconds.
  endif.
endform.
                  "displayStatus

*-----------------------------------------------------------------------
*  removeLeadingZeros...
*-----------------------------------------------------------------------
form removeLeadingZeros changing myValue.

  call function 'CONVERSION_EXIT_ALPHA_OUTPUT'
       exporting
            INPUT   = myValue
      importing
           OUTPUT  = myValue
       exceptions
            others  = 1.
endform.
             "removeLeadingZeros

*-----------------------------------------------------------------------
* determineFrontendOPSystem.... Determine the frontend operating system
* type.
*-----------------------------------------------------------------------
form determineFrontendOPSystem using separator
                                     operatingSystem.

data: platformID type i value 0.

  create object objFile.

  call method objFile->get_platform receiving platform = platformID
                                    exceptions cntl_error = 1
                                    error_no_gui = 2
                                    not_supported_by_gui = 3.
  case platformID.
    when objFile->PLATFORM_WINDOWS95
         or objFile->PLATFORM_WINDOWS98
         or objFile->PLATFORM_NT351
         or objFile->PLATFORM_NT40
         or objFile->PLATFORM_NT50
         or objFile->PLATFORM_MAC
         or objFile->PLATFORM_OS2
         or 14.      "XP
      separator = '\'.
      operatingSystem = NON_UNIX.
    when others.
      separator = '/'.
      operatingSystem = UNIX.
  endcase.
endform.
      "determineFrontendOpSystem

*-----------------------------------------------------------------------
* determineServerOPSystem.... Determine the server operating system type
.
*-----------------------------------------------------------------------
form determineServerOPSystem using separator
                                   serverFileSystem
                                   serverOpSystem.

* Find the file system
  select single fileSys
                from opSystem
                into serverFileSystem
                where opSys = sy-opsys.

  find 'WINDOWS' in serverFilesystem ignoring case.
  if sy-subrc = 0.
    separator = '\'.
    serverOpSystem = NON_UNIX.
  else.
    find 'DOS' in serverFilesystem ignoring case.
    if sy-subrc = 0.
      separator = '\'.
      serverOpSystem = NON_UNIX.
    else.
      separator = '/'.
      serverOpSystem = UNIX.
    endif.
  endif.
endform.
        "determineServerOpSystem

*-----------------------------------------------------------------------
* findExternalCommand.... Determine if the external command exists.  If
* it doesn't then disable the
*                         server input field
*-----------------------------------------------------------------------
form findExternalCommand.

  call function 'SXPG_COMMAND_CHECK'
    exporting
      commandname                      = 'ZMKDIR'
      operatingsystem                  = sy-opsys
    exceptions
      command_not_found                = 1
      others                           = 0.

  if sy-subrc <> 0.
    loop at screen.
      if screen-name = 'PLOGICAL'.
        screen-input = 0.
        modify screen.
      endif.

      if screen-name = 'PSERV'.
        screen-input = 0.
        modify screen.
      endif.

      if screen-name = 'PPC'.
        screen-input = 0.
        modify screen.
      endif.
    endloop.

    message s000(oo) with 'Download to server disabled,' 'external command ZMKDIR not defined.'.
  endif.
endform.

************************************************************************
********************************
*****************************************DOWNLOAD
*ROUTINES**********************************************
************************************************************************
********************************

*-----------------------------------------------------------------------
* downloadDDStructures... download database objects to file
*-----------------------------------------------------------------------
form downloadDDStructures using iLocDictionary like iDictionary[]
                                value(pathname)
                                value(HtmlFileExtension)
                                value(subDir)
                                value(sortTablesAsc)
                                value(slashSeparator)
                                value(saveToServer)
                                value(displayProgressMessage).

field-symbols: <waDictionary> type tDictTable.
data: tableFilename type string.
data: tableFilenameWithPath type string.
data: iHtmlTable type standard table of string with header line.
data: newSubDirectory type string.
data: completeSavePath type string.

  loop at iLocDictionary assigning <waDictionary>.
    perform buildFilename using pathName
                                subDir
                                <waDictionary>-tablename
                                space
                                space
                                HtmlFileExtension
                                IS_TABLE
                                saveToServer
                                slashSeparator
                                tableFilenameWithPath
                                tablefilename
                                newSubDirectory
                                completeSavePath.

*   Try and import a converted table to memory as it will be much
* quicker than converting it again
    import iHtmlTable from memory id <waDictionary>-tablename.
    if sy-subrc <> 0.
      concatenate 'Converting table' <waDictionary>-tablename 'to html'
into statusBarMessage separated by space.
      perform displayStatus using statusBarMessage 0.

      perform convertDDtoHTML using <waDictionary>-iStructure[]
                                    iHtmlTable[]
                                    <waDictionary>-tableName
                                    <waDictionary>-tableTitle
                                    sortTablesAsc.

      export iHtmlTable to memory id <waDictionary>-tablename.
    endif.

    if saveToServer is initial.
      perform saveFileToPc using iHtmlTable[]
                                 tableFilenameWithPath
                                 tableFilename
                                 space
                                 space
                                 displayProgressMessage.
    else.
      perform saveFileToServer using iHtmlTable[]
                                     tableFilenameWithPath
                                     tableFilename
                                     completeSavePath
                                     displayProgressMessage.
    endif.

    clear iHtmlTable[].
  endloop.
endform.
           "downloadDDStructures

*-----------------------------------------------------------------------
* downloadMessageClass...
*-----------------------------------------------------------------------
form downloadMessageClass using iLocMessages like iMessages[]
                                value(messageClassName)
                                value(userFilePath)
                                value(fileExtension)
                                value(HTMLfileFlag)
                                      subDir
                                value(syntaxHighlightComments)
                                value(customerNameRange)
                                value(getIncludes)
                                value(getDictStructures)
                                value(userHasSelectedMessageClasses)
                                value(slashSeparator)
                                value(saveToServer)
                                value(displayProgressMessage).

data: htmlPageName type string.
data: newFilenameOnly type string.
data: newFilenameWithPath type string.
data: iHtmlTable type standard table of string with header line.
data: newSubDirectory type string.
data: completeSavePath type string.

  perform appendMessagesToFile using iLocMessages[]
                                     iHtmlTable[]
                                     userHasSelectedMessageClasses.


  concatenate `message class ` messageClassName into htmlPageName.

  if htmlFileFlag is initial.
    append '' to iHtmlTable.
    append
'----------------------------------------------------------------------------------' to iHtmlTable.

    perform buildFooterMessage using 'TEXT'
                                     iHtmlTable.
    append iHtmlTable.
  else.
    perform convertCodeToHtml using iHtmlTable[]
                                    htmlPageName
                                    space
                                    IS_MESSAGECLASS
                                    ''
                                    FALSE
                                    syntaxHighlightComments
                                    fileExtension
                                    customerNameRange
                                    getIncludes
                                    getDictStructures.
  endif.

  perform buildFilename using userFilePath
                              subDir
                              messageClassName
                              space
                              space
                              fileExtension
                              IS_MESSAGECLASS
                              saveToServer
                              slashSeparator
                              newFilenameWithPath
                              newFilenameOnly
                              newSubDirectory
                              completeSavePath.

    if saveToServer is initial.
      perform saveFileToPc using iHtmlTable[]
                                 newFilenameWithPath
                                 newFilenameOnly
                                 space
                                 space
                                 displayProgressMessage.
    else.
*     Save the file to the SAP server
      perform saveFileToServer using iHtmlTable[]
                                     newFilenameWithPath
                                     newFilenameOnly
                                     completeSavePath
                                     displayProgressMessage.
    endif.
endform.
          "downloadMessageClass

*-----------------------------------------------------------------------
*  appendMessagesToFile
*-----------------------------------------------------------------------
form appendMessagesToFile using iLocMessages like iMessages[]
                                iLocHtml like dumiHtml[]
                                value(userHasSelectedMessageClasses).

data: previousMessageID like iMessages-arbgb.
field-symbols: <waMessage> type tMessage.
data: waHtml type string.

  sort iLocMessages ascending by arbgb msgnr.

  if not iLocMessages[] is initial.
    if userHasSelectedMessageClasses is initial.
*     Only add these extra lines if we are actually appending them to
* the end of some program code
      append waHtml to iLocHtml.
      append waHtml to iLocHtml.

      append '*Messages' to iLocHtml.
      append
 '*----------------------------------------------------------' to
iLocHtml.
    endif.

    loop at iLocMessages assigning <waMessage>.
      if ( <waMessage>-arbgb <> previousMessageID ).

        if userHasSelectedMessageClasses is initial.
*         Only add this extra lines if we are actually appending them to
* the end of some program code
          append '*' to iLocHtml.
          concatenate `* Message class: ` <waMessage>-arbgb into waHtml.
          append waHtml to iLocHtml.
        endif.

        previousMessageID = <waMessage>-arbgb.
        clear waHtml.
      endif.

      if userHasSelectedMessageClasses is initial.
*       Only add this extra lines if we are actually appending them to
* the end of some program code
        concatenate '*' <waMessage>-msgnr `   ` <waMessage>-text into
waHtml.
      else.
        concatenate <waMessage>-msgnr `   ` <waMessage>-text into waHtml
.
      endif.

      append waHtml to iLocHtml.
    endloop.
  endif.
endform.
           "appendMessagesToFile

*-----------------------------------------------------------------------
*  downloadFunctions...       Download function modules to file.
*-----------------------------------------------------------------------
form downloadFunctions using iLocFunctions like iFunctions[]
                             value(userFilePath)
                             value(fileExtension)
                             value(subDir)
                             value(downloadDocumentation)
                             value(convertToHtml)
                             value(syntaxHighlightComments)
                             value(customerNameRange)
                             value(getIncludes)
                             value(getDictStruct)
                             value(textFileExtension)
                             value(htmlFileExtension)
                             value(sortTablesAsc)
                             value(slashSeparator)
                             value(saveToServer)
                             value(displayProgressMessage).

data: mainSubdir type string.
data: incSubdir type string.
field-symbols: <waFunction> type tFunction.
field-symbols: <waInclude> type tInclude.
data: iEmptyTextelements type standard table of tTextTable.
data: iEmptySelectionTexts type standard table of tTextTable.
data: iEmptyMessages type standard table of tMessage.
data: iEmptyGuiTitles type standard table of tGuiTitle.
data: functionDocumentationExists type i value FALSE.

  loop at iLocFunctions assigning <waFunction>.
    if subDir is initial.
      incSubDir = <waFunction>-functionName.
      mainSubDir = ''.
    else.
      concatenate subdir <waFunction>-functionName into incSubDir
separated by slashSeparator.
      mainSubDir = subDir.
    endif.

    if not downloadDocumentation is initial.
      perform downloadFunctionDocs using <waFunction>-functionName
                                         <waFunction>-functionTitle
                                         userFilePath
                                         fileExtension
                                         convertToHtml
                                         slashSeparator
                                         saveToServer
                                         displayProgressMessage
                                         mainSubDir
                                         functionDocumentationExists.
    endif.

*   Download main source code
    perform readFunctionAndDownload using <waFunction>-iTextelements[]
                                          <waFunction>-iSelectionTexts[]
                                          <wafunction>-iMessages[]
                                          <wafunction>-functionName

<wafunction>-functionMainInclude
                                          <waFunction>-functionTitle
                                          userFilePath
                                          fileExtension
                                          mainSubDir
                                          convertToHtml
                                          functionDocumentationExists
                                          syntaxHighlightComments
                                          customerNameRange
                                          getIncludes
                                          getDictStruct
                                          slashSeparator
                                          saveToServer
                                          displayProgressMessage.

*   Download top include
    perform readIncludeAndDownload using iEmptyTextelements[]
                                         iEmptySelectionTexts[]
                                         iEmptyMessages[]
                                         iEmptyGuiTitles[]
                                         <waFunction>-topIncludeName
                                         <waFunction>-functionName
                                         <waFunction>-functionTitle
                                         IS_FUNCTION
                                         userFilePath
                                         fileExtension
                                         mainSubDir
                                         convertToHtml
                                         syntaxHighlightComments
                                         customerNameRange
                                         getIncludes
                                         getDictStruct
                                         slashSeparator
                                         saveToServer
                                         displayProgressMessage.

*   Download screens.
    if not <waFunction>-iScreenFlow[] is initial.
      perform downloadScreens using <wafunction>-iScreenFlow[]
                                    <wafunction>-progname
                                    userFilePath
                                    textFileExtension
                                    mainSubDir
                                    slashSeparator
                                    saveToServer
                                    displayProgressMessage.
    endif.

*   Download GUI titles
    if not <waFunction>-iGUITitle[] is initial.
      perform downloadGUITitles using <wafunction>-iGUITitle
                                      userFilePath
                                      textFileExtension
                                      mainsubDir
                                      slashSeparator
                                      saveToServer
                                      displayProgressMessage.
    endif.

*   Download all other includes
    loop at <wafunction>-iIncludes assigning <waInclude>.
      perform readIncludeAndDownload using iEmptyTextelements[]
                                           iEmptySelectionTexts[]
                                           iEmptyMessages[]
                                           iEmptyGuiTitles[]
                                           <waInclude>-IncludeName
                                           space
                                           <waInclude>-IncludeTitle
                                           IS_PROGRAM
                                           userFilePath
                                           fileExtension
                                           incSubDir
                                           convertToHtml
                                           syntaxHighlightComments
                                           customerNameRange
                                           getIncludes
                                           getDictStruct
                                           slashSeparator
                                           saveToServer
                                           displayProgressMessage.

    endloop.

*   Download all dictionary structures
    if not <wafunction>-iDictStruct[] is initial.
      perform downloadDDStructures using <wafunction>-iDictStruct[]
                                         userFilePath
                                         htmlFileExtension
                                         incSubDir
                                         sortTablesAsc
                                         slashSeparator
                                         saveToServer
                                         displayProgressMessage.
    endif.
  endloop.
endform.
              "downloadFunctions

*-----------------------------------------------------------------------
*   readIcludeAndDownload...
*-----------------------------------------------------------------------
form readIncludeAndDownload using iLocTextElements like dumiTextTab[]
                                  iLocSelectionTexts like dumiTextTab[]
                                  iLocMessages like iMessages[]
                                  iLocGUITitles like dumIGUITitle[]
                                  value(programName)
                                  value(functionName)
                                  value(shortText)
                                  value(overideProgType)
                                  value(userFilePath)
                                  value(fileExtension)
                                  value(additionalSubDir)
                                  value(convertToHtml)
                                  value(syntaxHighlightComments)
                                  value(customerNameRange)
                                  value(getIncludes)
                                  value(getDictStructures)
                                  value(slashSeparator)
                                  value(saveToServer)
                                  value(displayProgressMessage).

data: iLines type standard table of string with header line.
data: localFilenameWithPath type string.
data: localFilenameOnly type string.
data: newSubdirectory type string.
data: objectName type string.
data: completeSavePath type string.

  read report programName into iLines.

* Download GUI titles for main program
  if not iLocGUITitles[] is initial.
    perform appendGUITitles using iLocGUITitles[]
                                  iLines[].
  endif.

* Download text elements for main program
  if not iLocTextElements[] is initial.
    perform appendTextElements using iLocTextElements[]
                                     iLines[].
  endif.

* Download selection texts for main program
  if not iLocSelectiontexts[] is initial.
    perform appendSelectionTexts using iLocSelectiontexts[]
                                       iLines[].
  endif.

* Download messages classes for main program.
  if not iLocMessages[] is initial.
    perform appendMessagesToFile using iLocMessages[]
                                       iLines[]
                                       space.
  endif.

  if convertToHtml is initial.
    append '' to iLines.
    append
'----------------------------------------------------------------------------------' to iLines.
    perform buildFooterMessage using 'TEXT'
                                     iLines.
    append iLines.
  else.
    perform convertCodeToHtml using iLines[]
                                    programName
                                    shortText
                                    overideProgType
                                    space
                                    space
                                    syntaxHighlightComments
                                    fileExtension
                                    customerNameRange
                                    getIncludes
                                    getDictStructures.
  endif.

  if functionName is initial.
    objectName = programName.
  else.
    objectName = functionName.
  endif.

  perform buildFilename using userFilePath
                              additionalSubDir
                              objectName
                              space
                              programName
                              fileExtension
                              overideProgType
                              saveToServer
                              slashSeparator
                              localFilenameWithPath
                              localfilenameOnly
                              newSubdirectory
                              completeSavePath.

  if saveToServer is initial.
    perform saveFileToPc using iLines[]
                               localFilenameWithPath
                               localFilenameOnly
                               space
                               space
                               displayProgressMessage.
  else.
    perform saveFileToServer using iLines[]
                                   localFilenameWithPath
                                   localFilenameOnly
                                   completeSavePath
                                   displayProgressMessage.
  endif.
endform.
         "readIncludeAndDownload

*-----------------------------------------------------------------------
*   readClassAndDownload...
*-----------------------------------------------------------------------
form readClassAndDownload using waLocClass type tClass
                                value(className)
                                value(functionName)
                                value(overideProgType)
                                value(userFilePath)
                                value(fileExtension)
                                value(additionalSubDir)
                                value(convertToHtml)
                                value(syntaxHighlightComments)
                                value(customerNameRange)
                                value(getIncludes)
                                value(getDictStructures)
                                value(slashSeparator)
                                value(saveToServer)
                                value(displayProgressMessage).

data: iTempLines type standard table of string with header line.
data: iLines type standard table of string with header line.
data: localFilenameWithPath type string.
data: localFilenameOnly type string.
data: newSubdirectory type string.
data: objectName type string.
data: castClassName type program.
data: completeSavePath type string.

* Build up attribute comments
  append
'***********************************************************************' to iLines.
  append '*   Class attributes.           *' to iLines.
  append
'***********************************************************************' to iLines.
  case waLocClass-exposure.
    when 0.
      append `Instantiation: Private` to iLines.
    when 1.
      append `Instantiation: Protected` to iLines.
    when 2.
      append `Instantiation: Public` to iLines.
  endcase.
  concatenate `Message class: ` waLocClass-msg_id into iLines.
  append iLines.
  case waLocClass-state.
    when 0.
      append `State: Only Modelled` to iLines.
    when 1.
      append `State: Implemented` to iLines.
  endcase.
  concatenate `Final Indicator: ` waLocClass-clsfinal into iLines.
  append iLines.
  concatenate `R/3 Release: ` waLocClass-r3Release into iLines.
  append iLines.
  clear iLines.
  append iLines.

  castClassName = waLocClass-publicClassKey.
  read report castClassName into iTempLines.
  if sy-subrc = 0.
    perform reFormatClassCode using iTempLines[].

    append
'***********************************************************************' to iLines.
    append '*   Public section of class.             *' to iLines.
    append
'***********************************************************************' to iLines.
    loop at iTempLines.
      append iTempLines to iLines.
    endloop.
  endif.

  castClassName = waLocClass-privateClassKey.
  read report castClassName into iTempLines.
  if sy-subrc = 0.
    perform reFormatClassCode using iTempLines[].

    append iLines.
    append
'***********************************************************************' to iLines.
    append '*   Private section of class.             *' to iLines.
    append
'***********************************************************************' to iLines.
    loop at iTempLines.
      append iTempLines to iLines.
    endloop.
  endif.

  castClassName = waLocClass-ProtectedClassKey.
  read report castClassName into iTempLines.
  if sy-subrc = 0.
    perform reFormatClassCode using iTempLines[].

    append iLines.
    append
'***********************************************************************' to iLines.
    append '*   Protected section of class.             *' to iLines.
    append
'***********************************************************************' to iLines.
    loop at iTempLines.
      append iTempLines to iLines.
    endloop.
  endif.

  castClassName = waLocClass-typesClassKey.
  read report castClassName into iTempLines.
  if sy-subrc = 0.
    append iLines.
    append
'***********************************************************************' to iLines.
    append '*   Types section of class.             *' to iLines.
    append
'***********************************************************************' to iLines.
    loop at iTempLines.
      append iTempLines to iLines.
    endloop.
  endif.

* Download text elements for this class
  if not waLocClass-iTextElements[] is initial.
    perform appendTextElements using waLocClass-iTextElements[]
                                     iLines[].
  endif.

* Download messages classes for this class.
  if not waLocClass-iMessages[] is initial.
    perform appendMessagesToFile using waLocClass-iMessages[]
                                       iLines[]
                                       space.
  endif.

* Download exception texts for this class
  if not waLocClass-iConcepts[] is initial.
    perform appendExceptionTexts using waLocClass-iConcepts[]
                                       iLines[].
  endif.


  if convertToHtml is initial.
    append '' to iLines.
    append
'----------------------------------------------------------------------------------' to iLines.
    perform buildFooterMessage using 'TEXT'
                                     iLines.
    append iLines.
  else.
    perform convertClassToHtml using iLines[]
                                    className
                                    waLocClass-descript
                                    overideProgType
                                    syntaxHighlightComments
                                    fileExtension
                                    customerNameRange
                                    getDictStructures.
  endif.

  if functionName is initial.
    objectName = className.
  else.
    objectName = functionName.
  endif.

  perform buildFilename using userFilePath
                              additionalSubDir
                              objectName
                              space
                              className
                              fileExtension
                              overideProgType
                              saveToServer
                              slashSeparator
                              localFilenameWithPath
                              localfilenameOnly
                              newSubdirectory
                              completeSavePath.

  if saveToServer is initial.
    perform saveFileToPc using iLines[]
                               localFilenameWithPath
                               localFilenameOnly
                               space
                               space
                               displayProgressMessage.
  else.
    perform saveFileToServer using iLines[]
                                   localFilenameWithPath
                                   localFilenameOnly
                                   completeSavePath
                                   displayProgressMessage.
  endif.
endform.
           "readClassAndDownload

*-----------------------------------------------------------------------
*   readMethodAndDownload...
*-----------------------------------------------------------------------
form readMethodAndDownload using waLocMethod type tMethod
                                value(methodName)
                                value(methodKey)
                                value(functionName)
                                value(overideProgType)
                                value(userFilePath)
                                value(fileExtension)
                                value(additionalSubDir)
                                value(convertToHtml)
                                value(syntaxHighlightComments)
                                value(customerNameRange)
                                value(getIncludes)
                                value(getDictStructures)
                                value(slashSeparator)
                                value(saveToServer)
                                value(displayProgressMessage).

data: iLines type standard table of string with header line.
data: iTempLines type standard table of string with header line.
data: localFilenameWithPath type string.
data: localFilenameOnly type string.
data: newSubdirectory type string.
data: objectName type string.
data: castMethodKey type program.
data: completeSavePath type string.

* Add the method scope to the downloaded file
  append
'***********************************************************************' to iLines.
  append '*   Method attributes.           *' to iLines.
  append
'***********************************************************************' to iLines.
  case waLocMethod-exposure.
    when 0.
      append `Instantiation: Private` to iLines.
    when 1.
      append `Instantiation: Protected` to iLines.
    when 2.
      append `Instantiation: Public` to iLines.
  endcase.
  append
'***********************************************************************' to iLines.
  append '' to iLines.

  castMethodKey = waLocMethod-methodKey.
  read report castMethodKey into iTempLines.
  loop at iTempLines.
    append iTempLines to iLines.
  endloop.

  if convertToHtml is initial.
    append '' to iLines.
    append
'----------------------------------------------------------------------------------' to iLines.
    perform buildFooterMessage using 'TEXT'
                                     iLines.
    append iLines.
  else.
    perform convertCodeToHtml using iLines[]
                                    methodName
                                    waLocMethod-descript
                                    overideProgType
                                    space
                                    space
                                    syntaxHighlightComments
                                    fileExtension
                                    customerNameRange
                                    getIncludes

                                    getDictStructures.
  endif.

  if functionName is initial.
    objectName = methodName.
  else.
    objectName = functionName.
  endif.

  perform buildFilename using userFilePath
                              additionalSubDir
                              objectName
                              space
                              methodName
                              fileExtension
                              overideProgType
                              saveToServer
                              slashSeparator
                              localFilenameWithPath
                              localfilenameOnly
                              newSubdirectory
                              completeSavePath.

  if saveToServer is initial.
    perform saveFileToPc using iLines[]
                               localFilenameWithPath
                               localFilenameOnly
                               space
                               space
                               displayProgressMessage.
  else.
    perform saveFileToServer using iLines[]
                                   localFilenameWithPath
                                   localFilenameOnly
                                   completeSavePath
                                   displayProgressMessage.
  endif.
endform.
          "readMethodAndDownload

*-----------------------------------------------------------------------
*   readFunctionAndDownload...
*-----------------------------------------------------------------------
form readFunctionAndDownload using iLocTextElements like dumiTextTab[]
                                   iLocSelectionTexts like dumiTextTab[]
                                   iLocMessages like iMessages[]
                                   value(functionName)
                                   value(functionInternalName)
                                   value(shortText)
                                   value(userFilePath)
                                   value(fileExtension)
                                   value(subDir)
                                   value(convertToHtml)
                                   value(functionDocumentationExists)
                                   value(syntaxHighlightComments)
                                   value(customerNameRange)
                                   value(getIncludes)
                                   value(getDictStructures)
                                   value(slashSeparator)
                                   value(saveToServer)
                                   value(displayProgressMessage).

data: iLines type standard table of string with header line.
data: localFilenameWithPath type string.
data: localFilenameOnly type string.
data: newSubDirectory type string.
data: completeSavePath type string.

  read report functionInternalName into iLines.

* If we found any text elements for this function then we ought to
* append them to the main include.
  if not iLocTextElements[] is initial.
    perform appendTextElements using iLocTextElements[]
                                     iLines[].
  endif.

* If we found any message classes for this function then we ought to
* append them to the main include.
  if not iLocMessages[] is initial.
    perform appendMessagesToFile using iLocMessages[]
                                       iLines[]
                                       space.
  endif.

  if convertToHtml is initial.
    append '' to iLines.
    append
'----------------------------------------------------------------------------------' to iLines.
    perform buildFooterMessage using 'TEXT'
                                     iLines.
    append iLines.
  else.
    perform convertFunctionToHtml using iLines[]
                                        functionName
                                        shortText
                                        IS_FUNCTION
                                        functionDocumentationExists
                                        TRUE
                                        syntaxHighlightComments
                                        fileExtension
                                        customerNameRange
                                        getIncludes
                                        getDictStructures.
  endif.

  perform buildFilename using userFilePath
                              subDir
                              functionName
                              space
                              space
                              fileExtension
                              IS_FUNCTION
                              saveToServer
                              slashSeparator
                              localFilenameWithPath
                              localfilenameOnly
                              newSubDirectory
                              completeSavePath.

  if saveToServer is initial.
    perform saveFileToPc using iLines[]
                               localFilenameWithPath
                               localFilenameOnly
                               space
                               space
                               displayProgressMessage.
  else.
    perform saveFileToServer using iLines[]
                                   localFilenameWithPath
                                   localFilenameOnly
                                   completeSavePath
                                   displayProgressMessage.
  endif.
endform.
        "readFunctionAndDownload

*-----------------------------------------------------------------------
*  buildFilename...
*-----------------------------------------------------------------------
form buildFilename using value(userPath)
                         value(additionalSubDirectory)
                         value(objectName)
                         value(mainFunctionNo)
                         value(includeName)
                         value(fileExtension)
                         value(downloadType)
                         value(downloadToServer)
                         value(slashSeparator)
                               newFilenameWithPath
                               newFilenameOnly
                               newSubDirectory
                               completePath.

* If we are running on a non UNIX environment we will need to remove
* forward slashes from the additional path.
  if downloadToServer is initial.
    if frontendOpSystem = NON_UNIX.
      if not additionalSubdirectory is initial.
        translate additionalSubdirectory using '/_'.
        if additionalSubdirectory+0(1) = '_'.
          shift additionalSubdirectory left by 1 places.
        endif.
      endif.
    endif.
  else.
    if serverOpSystem = NON_UNIX.
      if not additionalSubdirectory is initial.
        translate additionalSubdirectory using '/_'.
        if additionalSubdirectory+0(1) = '_'.
          shift additionalSubdirectory left by 1 places.
        endif.
      endif.
    endif.
  endif.

  case downloadType.
*   Programs
    when IS_PROGRAM.
      if additionalSubDirectory is initial.
        concatenate userPath slashSeparator objectName PERIOD
fileExtension into newFilenameWithPath.
        concatenate userPath slashSeparator into completePath.
      else.
        concatenate userPath slashSeparator additionalSubdirectory
                             slashSeparator objectName PERIOD
fileExtension into newFilenameWithPath.
        concatenate userPath slashSeparator additionalSubdirectory into
completePath.
      endif.

*   Function Modules
    when IS_FUNCTION.
      if additionalSubdirectory is initial.
        find 'top' in includeName ignoring case.
        if sy-subrc = 0.
          concatenate userPath slashSeparator objectName
                               slashSeparator 'Global-' objectName
                               PERIOD fileExtension
                               into newFilenameWithPath.
        else.
          if includeName cs mainFunctionNo and not mainFunctionNo is
initial.
            concatenate userPath slashSeparator objectName
                                 slashSeparator objectName
                                 PERIOD fileExtension
                                 into newFilenameWithPath.
          else.
            concatenate userPath slashSeparator objectName
                                 slashSeparator objectName
                                 PERIOD fileExtension
                                 into newFilenameWithPath.
          endif.
        endif.
        newSubDirectory = objectName.
        concatenate userPath slashSeparator into completePath.
      else.
        find 'top' in includeName ignoring case.
        if sy-subrc = 0.
          concatenate userPath slashSeparator additionalSubdirectory
                               slashSeparator objectName
                               slashSeparator 'Global-' objectName
                               PERIOD fileExtension
                               into newFilenameWithPath.
        else.
          if includeName cs mainFunctionNo and not mainFunctionNo is
initial.
            concatenate userPath slashSeparator additionalSubdirectory
                                 slashSeparator objectName
                                 slashSeparator objectName
                                 PERIOD fileExtension
                                 into newFilenameWithPath.
          else.
            concatenate userPath slashSeparator additionalSubdirectory
                                 slashSeparator objectName
                                 slashSeparator objectName
                                 PERIOD fileExtension
                                 into newFilenameWithPath.
          endif.
        endif.
        concatenate additionalSubDirectory slashSeparator objectName
into newSubDirectory.
        concatenate userPath slashSeparator additionalSubdirectory
slashSeparator objectName into completePath.
      endif.

*   Table definition
    when IS_TABLE.
      if additionalSubdirectory is initial.
        concatenate userPath slashSeparator objectName
                             slashSeparator 'Dictionary-'
                             objectName PERIOD fileExtension
                             into newFilenameWithPath.

        concatenate userPath slashSeparator objectName into
NewSubDirectory.
        concatenate userPath slashSeparator objectName into completePath
.
      else.
        concatenate userpath slashSeparator additionalSubDirectory
                             slashSeparator objectName
                             slashSeparator 'Dictionary-'
                             objectName PERIOD fileExtension
                             into newFilenameWithPath.

        concatenate userPath slashSeparator additionalSubDirectory
slashSeparator objectName into newSubDirectory.
        concatenate userPath slashSeparator additionalSubDirectory
slashSeparator objectName into completePath.
      endif.

*   Program & Function documentation
    when IS_DOCUMENTATION.
      if additionalSubDirectory is initial.
        concatenate userPath slashSeparator objectName
                             slashSeparator 'Docs-'
                             objectName PERIOD
                             fileExtension
                             into newFilenameWithPath.

        concatenate userPath slashSeparator objectName into
newSubDirectory.
        concatenate userPath slashSeparator objectName into completePath
.
      else.
        concatenate userPath slashSeparator additionalSubDirectory
                             slashSeparator objectName
                             slashSeparator 'Docs-'
                             objectName PERIOD fileExtension
                             into newFilenameWithPath.

        concatenate userpath slashSeparator additionalSubDirectory
slashSeparator objectName into newSubDirectory.
        concatenate userpath slashSeparator additionalSubDirectory
slashSeparator objectName into completePath.
    endif.

*   Screens
    when IS_SCREEN.
      if additionalSubDirectory is initial.
        concatenate userpath slashSeparator 'Screens'
                             slashSeparator 'screen_'
                             objectName PERIOD
                             fileExtension into newFilenameWithPath.

        concatenate userPath slashSeparator 'screens' into
newSubDirectory.
        concatenate userPath slashSeparator 'screens' into completePath.

      else.
        concatenate userpath slashSeparator additionalSubdirectory
                             slashSeparator 'Screens'
                             slashSeparator 'screen_'
                             objectName PERIOD
                             fileExtension into newFilenameWithPath.

        concatenate userPath slashSeparator additionalSubDirectory
slashSeparator 'screens' into newSubDirectory.
        concatenate userPath slashSeparator additionalSubDirectory
slashSeparator 'screens' into completePath.
      endif.

*   GUI title
    when IS_GUITITLE.
      if additionalSubDirectory is initial.
        concatenate userpath slashSeparator 'Screens'
                             slashSeparator 'gui_title_'
                             objectName PERIOD
                             fileExtension into newFilenameWithPath.

        concatenate userPath slashSeparator 'screens' into
newSubDirectory.
        concatenate userPath slashSeparator 'screens' into completePath.
      else.
        concatenate userpath slashSeparator additionalSubdirectory
                             slashSeparator 'Screens'
                             slashSeparator 'gui_title_'
                             objectName PERIOD
                             fileExtension into newFilenameWithPath.

        concatenate userPath slashSeparator additionalSubDirectory
slashSeparator 'Screens' into newSubDirectory.
        concatenate userPath slashSeparator additionalSubDirectory
slashSeparator 'Screens' into completePath.
      endif.

*   Message Class
    when IS_MESSAGECLASS.
      if additionalSubDirectory is initial.
        concatenate userPath slashSeparator objectName
                             slashSeparator 'Message class-'
                             objectName PERIOD
                             fileExtension
                             into newFilenameWithPath.

        concatenate userPath slashSeparator objectName into
newSubDirectory.
        concatenate userPath slashSeparator objectName into completePath
.
      else.
        concatenate userPath slashSeparator additionalSubDirectory
                             slashSeparator objectName
                             slashSeparator 'Message class-'
                             objectName PERIOD fileExtension
                             into newFilenameWithPath.

        concatenate userpath slashSeparator additionalSubDirectory
slashSeparator objectName into newSubDirectory.
        concatenate userpath slashSeparator additionalSubDirectory
slashSeparator objectName into completePath.
    endif.

*   Class definition
    when IS_CLASS.
      if additionalSubdirectory is initial.
        concatenate userPath slashSeparator objectName
                             slashSeparator 'Class-'
                             objectName PERIOD fileExtension
                             into newFilenameWithPath.

        concatenate userPath slashSeparator objectName into
newSubDirectory.
        concatenate userPath slashSeparator objectName into completePath
.
      else.
        concatenate userpath slashSeparator additionalSubDirectory
                             slashSeparator objectName
                             slashSeparator 'Class-'
                             objectName PERIOD fileExtension
                             into newFilenameWithPath.

        concatenate userPath slashSeparator additionalSubDirectory
slashSeparator objectName into newSubDirectory.
        concatenate userPath slashSeparator additionalSubDirectory
slashSeparator objectName into completePath.
      endif.

*   Class definition
    when IS_METHOD.
      if additionalSubdirectory is initial.
        concatenate userPath slashSeparator 'Method-'
                             objectName PERIOD fileExtension
                             into newFilenameWithPath.

        concatenate userPath slashSeparator objectName into
newSubDirectory.
        concatenate userPath slashSeparator objectName into completePath
.
      else.
        concatenate userpath slashSeparator additionalSubDirectory
                             slashSeparator 'Method-'
                             objectName PERIOD fileExtension
                             into newFilenameWithPath.

        concatenate userPath slashSeparator additionalSubDirectory
slashSeparator objectName into newSubDirectory.
        concatenate userPath slashSeparator additionalSubDirectory
slashSeparator objectName into completePath.
      endif.
  endcase.

  translate completePath to lower case.
  concatenate objectName PERIOD fileExtension into newFilenameOnly.
  translate newFilenameOnly to lower case.
  translate newFilenameWithPath to lower case.
  translate newSubDirectory to lower case.

* If we are running on a non UNIX environment we will need to remove
* incorrect characters from the filename.
  if downloadToServer is initial.
    if frontendOpSystem = NON_UNIX.
      translate newFilenameOnly using '/_'.
      translate newFilenameWithPath using '/_'.
      translate newFilenameOnly using '< '.
      translate newFilenameWithPath using '< '.
      translate newFilenameOnly using '> '.
      translate newFilenameWithPath using '> '.
      translate newFilenameOnly using '? '.
      translate newFilenameWithPath using '? '.
      translate newFilenameOnly using '| '.
      translate newFilenameWithPath using '| '.
      condense newFilenameOnly no-gaps.
      condense newFilenameWithPath no-gaps.
    endif.
  else.
    if serverOpSystem = NON_UNIX.
      translate newFilenameOnly using '/_'.
      translate newFilenameWithPath using '/_'.
      translate newFilenameOnly using '< '.
      translate newFilenameWithPath using '< '.
      translate newFilenameOnly using '> '.
      translate newFilenameWithPath using '> '.
      translate newFilenameOnly using '? '.
      translate newFilenameWithPath using '? '.
      translate newFilenameOnly using '| '.
      translate newFilenameWithPath using '| '.
      condense newFilenameOnly no-gaps.
      condense newFilenameWithPath no-gaps.
    endif.
  endif.
endform.
                 "buildFilename

*-----------------------------------------------------------------------
*  saveFileToPc...    write an internal table to a file on the local PC
*-----------------------------------------------------------------------
form saveFileToPc using iDownload type standard table
                        value(filenameWithPath)
                        value(filename)
                        value(writeFieldSeparator)
                        value(truncateTrailingBlanks)
                        value(displayProgressMessage).

data: statusMessage type string.
data: objFile type ref to cl_gui_frontend_services.
data: strSubrc type string.

  if not displayProgressMessage is initial.
    concatenate `Downloading: ` filename into statusMessage.
    perform displayStatus using statusMessage 0.
  endif.

  create object objFile.
  call method objFile->gui_download exporting filename =
filenameWithPath
                                              filetype = 'ASC'
                                              write_field_separator =
writeFieldSeparator
                                              trunc_trailing_blanks =
truncateTrailingBlanks
                                     changing data_tab = iDownload[]
                                   exceptions file_write_error        =
1
                                              no_batch                =
2
                                              gui_refuse_filetransfer =
3
                                              invalid_type            =
4
                                              no_authority            =
5
                                              unknown_error           =
6
                                              header_not_allowed      =
7
                                              separator_not_allowed   =
8
                                              filesize_not_allowed    =
9
                                              header_too_long         =
10
                                              dp_error_create         =
11
                                              dp_error_send           =
12
                                              dp_error_write          =
13
                                              unknown_dp_error        =
14
                                              access_denied           =
15
                                              dp_out_of_memory        =
16
                                              disk_full               =
17
                                              dp_timeout              =
18
                                              file_not_found          =
19
                                              dataprovider_exception  =
20
                                              control_flush_error     =
21
                                              not_supported_by_gui    =
22
                                              error_no_gui            =
23.

   if sy-subrc <> 0.
     strSubrc = sy-subrc.
     concatenate `File save error: ` filename ` sy-subrc: ` strSubrc
into statusMessage.
     perform displayStatus using statusMessage 3.
   endif.
endform.
                                  "saveFileToPc

*-----------------------------------------------------------------------
*  saveFileToServer...    write an internal table to a file on the SAP
* server
*-----------------------------------------------------------------------
form saveFileToServer using iDownload type standard table
                            value(filenameWithPath)
                            value(filename)
                            value(path)
                            value(displayProgressMessage).

data: waDownload type string.
data: statusMessage type string.

  if not displayProgressMessage is initial.
    concatenate `Downloading: ` filename into statusMessage.
    perform displayStatus using statusMessage 0.
  endif.

  read table iServerPaths with key table_line = path.
  if sy-subrc <> 0.
    perform createServerDirectory using path.
    append path to iServerPaths.
  endif.

  open dataset filenameWithPath for output in text mode encoding default
.
  if sy-subrc = 0.
    loop at iDownload into waDownload.
      transfer waDownload to filenameWithPath.
      if sy-subrc <> 0.
        message e000(oo) with 'Error transferring data to file'.
      endif.
    endloop.

    close dataset filenameWithPath.
    if sy-subrc <> 0.
      message e000(oo) with 'Error closing file'.
    endif.
  else.
*   Unable to create a file
    message e000(oo) with 'Error creating file on SAP server' 'check permissions'.
  endif.
endform.
                              "saveFileToServer

*-----------------------------------------------------------------------
* createServerDirectory...
*-----------------------------------------------------------------------
form createServerDirectory using value(path).

*  Parameters for remove command.
data: param1 type sxpgcolist-parameters.
*  Return status
data: funcStatus type extcmdexex-status.
*  Command line listing returned by the function
data: iServerOutput type standard table of btcxpm.
data: waServeroutput type btcxpm.
*  Targetsystem type conversion variable.
data: target type rfcdisplay-rfchost.
* Operating system
data: operatingSystem type sxpgcolist-opsystem.
*  Head for split command.
data: head type string..
data: tail type string.

 param1 = path.
 target = sy-host.
 operatingSystem = sy-opsys.

 call function 'SXPG_COMMAND_EXECUTE'
   exporting
     commandname                         = 'ZMKDIR'
     additional_parameters               = param1
     operatingsystem                     = operatingSystem
     targetsystem                        = target
     stdout                              = 'X'
     stderr                              = 'X'
     terminationwait                     = 'X'
   importing
     status                              = funcStatus
   tables
     exec_protocol                       = iServerOutput[]
   exceptions
    no_permission                       = 1
    command_not_found                   = 2
    parameters_too_long                 = 3
    security_risk                       = 4
    wrong_check_call_interface          = 5
    program_start_error                 = 6
    program_termination_error           = 7
    x_error                             = 8
    parameter_expected                  = 9
    too_many_parameters                 = 10
    illegal_command                     = 11
    wrong_asynchronous_parameters       = 12
    cant_enq_tbtco_entry                = 13
    jobcount_generation_error           = 14
    others                              = 15.

  if sy-subrc = 0.
*   Although the function succeded did the external command actually
* work
    if funcStatus = 'E'.
*     External command returned with an error
      if sy-opsys cs 'Windows NT'.
        read table iServeroutput index 1 into waServeroutput.
        if waServeroutput-message ns 'already exists'.
*         An error occurred creating the directory on the server
          message e000(oo) with 'An error occurred creating a directory'
.
        endif.
      else.
        read table iServerOutput index 2 into waServeroutput.
        split waServeroutput-message at space into head tail.
        shift tail left deleting leading space.
        if tail <> 'Do not specify an existing file.'.
*         An error occurred creating the directory on the server
          message e000(oo) with 'An error occurred creating a directory'
.
        endif.
      endif.
    endif.
  else.
    case sy-subrc.
      when 1.
*       No permissions to run the command
        message e000(oo) with 'No permissions to run external command ZMKDIR'.
      when 2.
*       External command not found
        message E000(oo) with 'External comand ZMKDIR not found'.

      when others.
*       Unable to create the directory
        message e000(oo) with 'An error occurred creating a directory'
                              ', subrc:'
                              sy-subrc.
    endcase.
  endif.
endform.
                         "createServerDirectory

*-----------------------------------------------------------------------
* appendTextElements...
*-----------------------------------------------------------------------
form appendTextElements using iLocTextElements like dumiTextTab[]
                              iLocLines like dumiHtml[].

field-symbols: <waTextElement> type tTextTable.
data: waLine type string.

  if lines( iLocTextElements ) > 0.
    append '' to iLocLines.

    append '*Text elements' to iLocLines.
    append '*----------------------------------------------------------'
 to  iLocLines.
    loop at iLocTextElements assigning <waTextElement>.
      concatenate '*  ' <waTextElement>-key <waTextElement>-entry into
waLine separated by space.
      append waLine to iLocLines.
    endloop.
  endif.
endform.
                            "appendTextElements

*-----------------------------------------------------------------------
* appendGUITitles...
*-----------------------------------------------------------------------
form appendGUITitles using iLocGUItitles like dumiGUITitle[]
                           iLocLines like dumiHtml[].

field-symbols: <waGUITitle> type tGUITitle.
data: waLine type string.

  if lines( iLocGUItitles ) > 0.
    append '' to iLocLines.

    append '*GUI Texts' to iLocLines.
    append '*----------------------------------------------------------'
 to  iLocLines.
    loop at iLocGUItitles assigning <waGUItitle>.
      concatenate '*  ' <waGUItitle>-obj_code '-->' <waGUItitle>-text
into waLine separated by space.
      append waLine to iLocLines.
    endloop.
  endif.
endform.
                               "appendGUITitles

*-----------------------------------------------------------------------
* appendSelectionTexts...
*-----------------------------------------------------------------------
form appendSelectionTexts using iLocSelectionTexts like dumiTextTab[]
                                iLocLines like dumiHtml[].

field-symbols: <waSelectionText> type tTextTable.
data: waLine type string.

  if lines( iLocSelectionTexts ) > 0.
    append '' to iLocLines.
    append '' to iLocLines.

    append '*Selection texts' to iLocLines.
    append '*----------------------------------------------------------'
 to  iLocLines.
    loop at iLocSelectiontexts assigning <waSelectionText>.
      concatenate '*  ' <waSelectionText>-key <waSelectionText>-entry
into waLine separated by space.
      append waLine to iLocLines.
    endloop.
  endif.
endform.
                          "appendSelectionTexts

*-----------------------------------------------------------------------
* appendExceptionTexts...
*-----------------------------------------------------------------------
form appendExceptionTexts using iConcepts like dumiConcepts[]
                                iLocLines like dumiHtml[].

field-symbols: <waConcept> type tConcept.
data: waLine type string.
data: conceptText type sotr_txt.

  if lines( iConcepts ) > 0.
    append '' to iLocLines.

    append '*Exception texts' to iLocLines.
    append '*----------------------------------------------------------'
 to  iLocLines.
    loop at iConcepts assigning <waConcept>.
*     Find the text for this concept
      call function 'SOTR_GET_TEXT_KEY' exporting concept =
<waConcept>-concept
                                                  langu = sy-langu
                                                  search_in_second_langu
 = 'X'
*                                                  second_langu = 'DE'
                                        importing e_text = conceptText
                                        exceptions no_entry_found = 1
                                                   parameter_error = 2
                                                   others  = 3.

      if sy-subrc = 0.
        concatenate '*  ' <waConcept>-constName '-' conceptText  into
waLine separated by space.
        append waLine to iLocLines.
      endif.
    endloop.
  endif.
endform.
                          "appendExceptionTexts

*-----------------------------------------------------------------------
* downloadFunctionDocs...
*-----------------------------------------------------------------------
form downloadFunctionDocs using value(functionName)
                                value(functionDescription)
                                value(userFilePath)
                                value(fileExtension)
                                value(convertToHtml)
                                value(slashSeparator)
                                value(saveToServer)
                                value(displayProgressMessage)
                                      subDir
                                      documentationDownloaded.

data: iLines type standard table of string with header line.
data: iDocumentation type standard table of funct with header line.
data: iExceptions type standard table of rsexc with header line.
data: iExport type standard table of rsexp with header line.
data: iParameter type standard table of rsimp with header line.
data: iTables type standard table of rstbl with header line.
data: iScriptLines type standard table of tline with header line.
data: htmlPageName type string.
data: newFilenameWithPath type string.
data: newFilenameOnly type string.
data: object like dokhl-object.
data: stringLength type i value 0.
data: newSubDirectory type string.
data: waLine(255).
data: completeSavePath type string.

  documentationDownloaded = FALSE.
  object = functionName.

  call function 'FUNCTION_IMPORT_DOKU'
       exporting
            funcName           = functionName
       tables
            DOKUMENTATION      = iDocumentation
            EXCEPTION_LIST     = iExceptions
            EXPORT_PARAMETER   = iExport
            IMPORT_PARAMETER   = iParameter
            TABLES_PARAMETER   = iTables
       exceptions
            ERROR_MESSAGE      = 1
            FUNCTION_NOT_FOUND = 2
            INVALID_NAME       = 3
            others             = 4.

  call function 'DOCU_GET'
       exporting
            ID                     = 'FU'
            LANGU                  = sy-langu
            OBJECT                 = object
            TYP                    = 'T'
            VERSION_ACTIVE_OR_LAST = 'L'
       tables
            line                   = iScriptLines
       exceptions
            NO_DOCU_ON_SCREEN      = 1
            NO_DOCU_SELF_DEF       = 2
            NO_DOCU_TEMP           = 3
            RET_CODE               = 4
            others                 = 5.

  if sy-subrc = 0 and not ( iScriptLines[] is initial ).
    append 'SHORT TEXT' to iLines.
    concatenate space functionDescription into functionDescription
separated by space.
    append functionDescription to iLines.
    append space to iLines.
    loop at iScriptLines.
      move iScriptLines-tdline to iLines.
      concatenate space iLines into iLines separated by space.
      while iLines CP '&*' or iLines CP '*&'.
        replace '&' into iLines with space.
        shift iLines left deleting leading space.
      endwhile.
      append iLines.
    endloop.

    clear iLines.
    if not ( iDocumentation[] is initial ).
      append iLines.
      append 'PARAMETER DOCUMENTATION' to iLines.
      append '-----------------------' to iLines.
      append iLines.

      describe field iDocumentation-parameter length stringLength in
character mode.
      stringLength = stringLength + 3.
      loop at iDocumentation.
        move iDocumentation-parameter to waLine.
        move iDocumentation-stext to waLine+stringLength.
        append waLine to iLines.
      endloop.
    endif.

    concatenate `Documentation - ` functionName into htmlPageName.

    if convertToHtml is initial.
      append iLines.
      append
'----------------------------------------------------------------------------------' to iLines.
      append iLines.
      perform buildFooterMessage using 'TEXT'
                                       iLines.
      append iLines.
    else.
      perform convertCodeToHtml using iLines[]
                                      htmlPageName
                                      space
                                      IS_DOCUMENTATION
                                      TRUE
                                      space
                                      space
                                      space
                                      space
                                      space
                                      space.
    endif.

    perform buildFilename using userFilePath
                                subDir
                                functionName
                                space
                                space
                                fileExtension
                                IS_DOCUMENTATION
                                saveToServer
                                slashSeparator
                                newFilenameWithPath
                                newFilenameOnly
                                newSubDirectory
                                completeSavePath.

    if saveToServer is initial.
      perform saveFileToPC using iLines[]
                                 newFilenameWithPath
                                 newfilenameOnly
                                 space
                                 space
                                 displayProgressMessage.
    else.
      perform saveFileToServer using iLines[]
                                     newFilenameWithPath
                                     newfilenameOnly
                                     completeSavePath
                                     displayProgressMessage.
    endif.

    documentationDownloaded = TRUE.
  endif.
endform.
                          "downloadFunctionDocs

*-----------------------------------------------------------------------
*  downloadScreens...
*-----------------------------------------------------------------------
form downloadScreens using iLocScreenFlow like dumiScreen[]
                           value(programName)
                           value(userFilePath)
                           value(textFileExtension)
                           value(subdir)
                           value(slashSeparator)
                           value(saveToServer)
                           value(displayProgressMessage).


tables: d020t.
data: header like d020s.
data: iFields type standard table of d021s with header line.
data: iFlowLogic type standard table of d022s with header line.
field-symbols <waScreen> type tScreenFlow.
data: waCharHeader type scr_chhead.
data: iScreenChar type standard table of scr_chfld with header line.
data: iFieldsChar type standard table of scr_chfld with header line.
data: stars type string value
'****************************************************************'.
data: comment1 type string value '*   This file was generated by Direct Download Enterprise.     *'.
data: comment2 type string value '*   Please do not change it manually.                         *'.
data: dynproText type string value '%_DYNPRO'.
data: headerText type string value '%_HEADER'.
data: paramsText type string value '%_PARAMS'.
data: descriptionText type string value '%_DESCRIPTION'.
data: fieldsText type string value '%_FIELDS'.
data: flowlogicText type string value '%_FLOWLOGIC'.
data: programLength type string.
data: newSubDirectory type string.
data: newFilenameWithPath type string.
data: newFilenameOnly type string.
data: completeSavePath type string.

  loop at iLocScreenFlow assigning <waScreen>.
    call function 'RS_IMPORT_DYNPRO'
         exporting
              dylang = sy-langu
              dyname = programName
              dynumb = <waScreen>-screen
         importing
              header = header
         tables
              ftab   = iFields
              pltab  = iFlowLogic.

    call function 'RS_SCRP_HEADER_RAW_TO_CHAR'
         exporting
              header_int  = header
         importing
              header_char = waCharHeader
         exceptions
              others      = 1.

*   Add in the top comments for the file
    append stars to iScreenChar .
    append comment1 to iScreenChar.
    append comment2 to iScreenChar.
    append stars to iScreenChar.

*   Screen identification
    append dynproText to iScreenChar.
    append waCharHeader-prog to iScreenChar.
    append waCharHeader-dnum to iScreenChar.
    append sy-saprl to iScreenChar.
    describe field d020t-prog length programLength in character mode.
    concatenate `                ` programLength into iScreenChar.
    append iScreenChar.

*   Header
    append headerText to iScreenChar.
    append waCharHeader to iScreenChar.

*   Description text
    append descriptionText to iScreenChar.
    select single dtxt from d020T into iScreenChar
                       where prog = programName
                             and dynr = <waScreen>-screen
                             and lang = sy-langu.
    append iScreenChar.

*   Fieldlist text
    append fieldsText to iScreenChar.

    call function 'RS_SCRP_FIELDS_RAW_TO_CHAR'
         tables
              fields_int  = iFields[]
              fields_char = iFieldsChar[]
         exceptions
              others      = 1.

    loop at iFieldsChar.
      move-corresponding iFieldsChar to iScreenChar.
      append iScreenChar.
    endloop.

*   Flowlogic text
    append flowlogicText to iScreenChar.
*   Flow logic.
    loop at iFlowLogic.
      append iFlowLogic to iScreenChar.
    endloop.

    perform buildFilename using userFilePath
                                subDir
                                waCharHeader-dnum
                                space
                                space
                                textFileExtension
                                IS_SCREEN
                                saveToServer
                                slashSeparator
                                newFilenameWithPath
                                newfilenameOnly
                                newSubDirectory
                                completeSavePath.

    if saveToServer is initial.
*     Save the screen to the local computer
      perform saveFileToPc using iScreenChar[]
                                 newFilenameWithPath
                                 newFilenameOnly
                                 'X'
                                 'X'
                                 displayProgressMessage.
    else.
*     Save the screen to the SAP server
      perform saveFileToServer using iScreenChar[]
                                     newFilenameWithPath
                                     newFilenameOnly
                                     completeSavePath
                                     displayProgressMessage.
    endif.

    clear header. clear waCharHeader.
    clear iScreenChar[].
    clear iFieldsChar[].
    clear iFields[].
    clear iFlowLogic[].
  endloop.
endform.
                               "downloadScreens

*-----------------------------------------------------------------------
*  downloadGUITitles..
*-----------------------------------------------------------------------
form downloadGUITitles using iLocGUITitles like dumIGUITitle[]
                             value(userFilePath)
                             value(textFileExtension)
                             value(subDir)
                             value(slashSeparator)
                             value(saveToServer)
                             value(displayProgressMessage).

data: iLines type standard table of string with header line.
field-symbols: <waGUITitle> type tGUITitle.
data: newSubDirectory type string.
data: newFilenameWithPath type string.
data: newFilenameOnly type string.
data: completeSavePath type string.

  loop at iLocGUITitles assigning <waGUITitle>.
    append <waGUITitle>-text to iLines.

    perform buildFilename using userFilePath
                                subDir
                                <waGUITitle>-obj_code
                                space
                                space
                                textFileExtension
                                IS_GUITITLE
                                saveToServer
                                slashSeparator
                                newFilenameWithPath
                                newfilenameOnly
                                newSubDirectory
                                completeSavePath.

    if saveToServer is initial.
      perform saveFileToPc using iLines[]
                                 newFilenameWithPath
                                 newFilenameOnly
                                 space
                                 space
                                 displayProgressMessage.
    else.
      perform saveFileToServer using iLines[]
                                     newFilenameWithPath
                                     newFilenameOnly
                                     completeSavePath
                                     displayProgressMessage.
    endif.

    clear iLines[].
  endloop.
endform.
                             "downloadGUITitles

*-----------------------------------------------------------------------
*  downloadPrograms..
*-----------------------------------------------------------------------
form downloadPrograms using iLocProgram like iPrograms[]
                            iLocFunctions like iFunctions[]
                            value(userFilePath)
                            value(fileExtension)
                            value(htmlFileExtension)
                            value(textFileExtension)
                            value(convertToHtml)
                            value(syntaxHighlightComments)
                            value(customerNameRange)
                            value(getIncludes)
                            value(getDictStruct)
                            value(downloadDocumentation)
                            value(sortTablesAsc)
                            value(slashSeparator)
                            value(saveToServer)
                            value(displayProgressMessage).


data: iProgFunctions type standard table of tFunction with header line.
field-symbols: <waProgram> type tProgram.
field-symbols: <waInclude> type tInclude.
data: iEmptyTextelements type standard table of tTextTable.
data: iEmptySelectionTexts type standard table of tTextTable.
data: iEmptyMessages type standard table of tMessage.
data: iEmptyGuiTitles type standard table of tGUITitle.
data: locConvertToHtml(1).
data: locFileExtension type string.

  sort iLocProgram ascending by progname.

  loop at iLocProgram assigning <waProgram>.
*   if the program to download is this program then always download as
* text otherwise you will get a rubbish file
    if <waprogram>-progname = sy-cprog.
      locConvertToHtml = ''.
      locFileExtension = TEXTEXTENSION.
    else.
      locConvertToHtml = convertToHtml.
      locFileExtension = fileExtension.
    endif.

*   Download the main program
    perform readIncludeAndDownload using <waProgram>-iTextelements[]
                                         <waProgram>-iSelectionTexts[]
                                         <waProgram>-iMessages[]
                                         <waProgram>-iGUITitle[]
                                         <waprogram>-progname
                                         space
                                         <waprogram>-programTitle
                                         IS_PROGRAM
                                         userFilePath
                                         locFileExtension
                                         <waprogram>-progname
                                         locConvertToHtml
                                         syntaxHighlightComments
                                         customerNameRange
                                         getIncludes
                                         getDictStruct
                                         slashSeparator
                                         saveToServer
                                         displayProgressMessage.

*   Download screens.
    if not <waProgram>-iScreenFlow[] is initial.
      perform downloadScreens using <waProgram>-iScreenFlow[]
                                    <waProgram>-progname
                                    userFilePath
                                    textFileExtension
                                    <waprogram>-progname
                                    slashSeparator
                                    saveToServer
                                    displayProgressMessage.
    endif.

*   Download GUI titles
    if not <waProgram>-iGUITitle[] is initial.
      perform downloadGUITitles using <waProgram>-iGUITitle
                                      userFilePath
                                      textFileExtension
                                      <waProgram>-progName
                                      slashSeparator
                                      saveToServer
                                      displayProgressMessage.
    endif.

*   Download all other includes
    loop at <waProgram>-iIncludes assigning <waInclude>.
      perform readIncludeAndDownload using iEmptyTextelements[]
                                           iEmptySelectionTexts[]
                                           iEmptyMessages[]
                                           iEmptyGuiTitles[]
                                           <waInclude>-IncludeName
                                           space
                                           <waInclude>-IncludeTitle
                                           IS_PROGRAM
                                           userFilePath
                                           fileExtension
                                           <waProgram>-progName
                                           convertToHtml
                                           syntaxHighlightComments
                                           customerNameRange
                                           getIncludes
                                           getDictStruct
                                           slashSeparator
                                           saveToServer
                                           displayProgressMessage.

    endloop.

*   Download all dictionary structures
    if not <waProgram>-iDictStruct[] is initial.
      perform downloadDDStructures using <waProgram>-iDictStruct[]
                                         userFilePath
                                         htmlFileExtension
                                         <waProgram>-progName
                                         sortTablesAsc
                                         slashSeparator
                                         saveToServer
                                         displayProgressMessage.
    endif.

*   Download any functions used by these programs
    loop at iLocFunctions into iProgFunctions where programLinkName =
<waProgram>-progName.
      append iProgFunctions.
    endloop.

    if not iProgFunctions[] is initial.
      perform downloadFunctions using iProgFunctions[]
                                      userFilePath
                                      fileExtension
                                      <waProgram>-progName
                                      downloadDocumentation
                                      convertToHtml
                                      syntaxHighlightComments
                                      customerNameRange
                                      getIncludes
                                      getDictStruct
                                      textFileExtension
                                      htmlFileExtension
                                      sortTablesAsc
                                      slashSeparator
                                      saveToServer
                                      displayProgressMessage.
       clear iProgFunctions[].
     endif.
  endloop.
endform.
                              "downloadPrograms

*-----------------------------------------------------------------------
*  downloadClasses..
*-----------------------------------------------------------------------
form downloadClasses using iLocClasses like iClasses[]
                           iLocFunctions like iFunctions[]
                           value(userFilePath)
                           value(fileExtension)
                           value(htmlFileExtension)
                           value(textFileExtension)
                           value(convertToHtml)
                           value(syntaxHighlightComments)
                           value(customerNameRange)
                           value(getIncludes)
                           value(getDictStruct)
                           value(downloadDocumentation)
                           value(sortTablesAsc)
                           value(slashSeparator)
                           value(saveToServer)
                           value(displayProgressMessage).


data: iClassFunctions type standard table of tFunction with header line.
field-symbols: <waClass> type tClass.
field-symbols: <waMethod> type tMethod.

  sort iLocClasses ascending by clsname.

  loop at iLocClasses assigning <waClass>.
*   Download the class
    perform readClassAndDownload using <waClass>
                                        <waClass>-clsname
                                        space
                                        IS_CLASS
                                        userFilePath
                                        fileExtension
                                        space
                                        convertToHtml
                                        syntaxHighlightComments
                                        customerNameRange
                                        getIncludes
                                        getDictStruct
                                        slashSeparator
                                        saveToServer
                                        displayProgressMessage.


*   Download all of the methods
    loop at <waClass>-iMethods assigning <waMethod>.
    perform readMethodAndDownload using <waMethod>
                                        <waMethod>-cmpName
                                        <waMethod>-methodKey
                                        space
                                        IS_METHOD
                                        userFilePath
                                        fileExtension
                                        <waClass>-clsName
                                        convertToHtml
                                        syntaxHighlightComments
                                        customerNameRange
                                        getIncludes
                                        getDictStruct
                                        slashSeparator
                                        saveToServer
                                        displayProgressMessage.

    endloop.

*   Download all dictionary structures
    if not <waClass>-iDictStruct[] is initial.
      perform downloadDDStructures using <waClass>-iDictStruct[]
                                         userFilePath
                                         htmlFileExtension
                                         <waClass>-clsName
                                         sortTablesAsc
                                         slashSeparator
                                         saveToServer
                                         displayProgressMessage.
    endif.

*   Download any functions used by these programs
    loop at iLocFunctions into iClassFunctions where programLinkName =
<waClass>-clsName.
      append iClassFunctions.
    endloop.

    if not iClassFunctions[] is initial.
      perform downloadFunctions using iClassFunctions[]
                                      userFilePath
                                      fileExtension
                                      <waClass>-clsName
                                      downloadDocumentation
                                      convertToHtml
                                      syntaxHighlightComments
                                      customerNameRange
                                      getIncludes
                                      getDictStruct
                                      textFileExtension
                                      htmlFileExtension
                                      sortTablesAsc
                                      slashSeparator
                                      saveToServer
                                      displayProgressMessage.
       clear iClassFunctions[].
     endif.
  endloop.
endform.
                               "downloadClasses

*-----------------------------------------------------------------------
*  reFormatClassCode...   Expand a classes public, private and protected
* section from the 72 characters that the class
*                         builder sets it to back to the wide editor
* mode
*-----------------------------------------------------------------------
form reFormatClassCode using iTempLines like dumiHtml[].

field-symbols: <waLine> type string.
data: newLine type string.
data: iNewTable type standard table of string.
data: foundOne type i value FALSE.

  loop at iTempLines assigning <waLine>.
    if not <waLine> is initial.
      if foundOne = FALSE.
        find 'data' in <waLine> respecting case.
        if sy-subrc = 0.
          foundOne = TRUE.
        endif.

        find 'constants' in <waLine> respecting case.
        if sy-subrc = 0.
          foundOne = TRUE.
        endif.

        if foundOne = TRUE.
          newLine = <waLine>.

          if ( newLine cs '.' or newLine cs '*' ).
            replace '!' in <waLine> with ''.
            append newLine to iNewTable.
            clear newLine.
            foundOne = FALSE.
          endif.
        else.
          replace '!' in <waLine> with ''.
          append <waLine> to iNewTable.
        endif.
      else.
        concatenate newLine <waLine> into newLine separated by space.
        if ( newLine cs '.' or newLine cs '*' ).
          append newLine to iNewTable.
          clear newLine.
          foundOne = FALSE.
        endif.
      endif.
    else.
      replace '!' in <waLine> with ''.
      append <waLine> to iNewTable[].
    endif.
  endloop.

  iTempLines[] = iNewTable[].
endform.
             "reFormatClassCode

************************************************************************
***********************************************
**********************************************HTML
*ROUTINES************************************************************
************************************************************************
***********************************************

*-----------------------------------------------------------------------
*  convertDDToHTML...   Convert text description to HTML
*-----------------------------------------------------------------------
form convertDDToHTML using iLocDictStructure like dumiDictStructure[]
                           iLocHtml like dumiHtml[]
                           value(tableName)
                           value(tableTitle)
                           value(sortTablesAsc).

data: iColumnCaptions type standard table of string with header line.
data: waDictionary type tDictTableStructure.
data: waHtml type string.
data: title type string.

  perform buildColumnHeaders using iColumnCaptions[].

* Add a html header to the table
  concatenate 'Dictionary object-' tablename into title separated by
space.
  perform addHTMLHeader using iLocHtml[]
                              title.

  concatenate '<h2>' tableName '</h2>' into waHtml.
  append waHtml to iLocHtml.
  append '' to iLocHtml.

  concatenate '<h3>' tableTitle '</h3>' into waHtml.
  append waHtml to iLocHtml.
  append '' to iLocHtml.

* Do we need to sort the fields into alphabetical order
  if not sortTablesAsc is initial.
    sort iLocDictStructure ascending by fieldname.
  endif.

  perform convertITABtoHtml using iColumnCaptions[]
                                  iLocDictStructure[]
                                  iLocHtml
                                  'X'
                                  COLOUR_BLACK
                                  ''
                                  COLOUR_YELLOW
                                  ''
                                  BACKGROUND_COLOUR
                                  'Arial'
                                  'green'
                                  '1'
                                  '1'.

* Add a html footer to the table
  append '<br>' to iLocHtml.
  perform addHtmlFooter using iLocHtml[].
endform.
                               "convertDDToHTML

*-----------------------------------------------------------------------
*  convertITABtoHtml... produces a html table from an internal table
*-----------------------------------------------------------------------
form convertITABtoHtml using iLocHeader like dumIHeader[]
                             iLocDictStructure like dumiDictStructure[]
                             iLocHtml like dumiHtml[]
                             value(includeRowCount)
                             headingBackColour
                             headingFontName
                             headingFontColour
                             headingFontSize
                             bodyBackColour
                             bodyFontName
                             bodyFontColour
                             bodyFontSize
                             borderSize.

* Holds one cell from the internal table
field-symbols: <fsField>.
* The value of one cell form the internal table
data: wTextCell type string.
* work area for putting the CSV value into
data: waCsvTable type string.
* Have we used any font tags in the html code
data: usedAFontAttribute type i value 0.
* Work area for HTML table
data: waHtml type string.
* Loop counter for adding row numbers onto the output table
data: loopCounter type string.
* Work area for header table
field-symbols: <waHeader> type string.
field-symbols: <iLocDictStructure> type tDictTableStructure.

  concatenate '<table border="' borderSize '">' into waHtml.
  append waHtml to iLocHtml.

  if not iLocHeader[] is initial.
    append '<tr>' to iLocHtml.
  endif.

  loop at iLocHeader assigning <waHeader>.
    if headingBackColour is initial.
      waHtml = '<th>'.
    else.
      concatenate '<th bgcolor="' headingBackColour '">' into waHtml.
    endif.

    if not headingFontName is initial or not headingFontColour is
initial or not headingFontSize is initial.
       concatenate waHtml '<font' into waHtml.

*      Add the font name
       if not headingFontName is initial.
          concatenate waHtml ' face ="' into waHtml.
          concatenate waHtml headingFontName '"' into waHtml.
       endif.

*      Add the font colour
       if not headingFontColour is initial.
          concatenate waHtml ' color ="' into waHtml.
          concatenate waHtml headingFontColour '"' into waHtml.
       endif.

*      Add the fontsize
       if not headingFontSize is initial.
          concatenate waHtml' size ="' into waHtml.
          concatenate waHtml  headingFontSize '"' into waHtml.
       endif.

       concatenate waHtml '>' into waHtml.
       usedAFontAttribute = TRUE.
    endif.

*   Add the caption name
    concatenate waHtml <waHeader> into waHtml.

    if usedAFontattribute = TRUE.
      concatenate waHtml '</font>' into waHtml.
      usedAFontAttribute = FALSE.
    endif.

    concatenate waHtml '</th>' into waHtml.
    append waHtml to iLocHtml.
  endloop.

  append '</tr>' to iLocHtml.
  free iLocHeader.


*  Line item data
  loop at iLocDictStructure assigning <iLocDictStructure>.

    loopCounter = sy-tabix.

    append '' to iLocHtml.
    append '<tr>' to iLocHtml.

*   Add the row count
    if not includeRowCount is initial.
      if BodyBackColour is initial.
        waHtml = '<td>'.
      else.
        concatenate '<td bgcolor="' bodyBackColour '">' into waHtml.
      endif.

      if not bodyFontName is initial or not bodyFontColour is initial or
 not bodyFontSize is initial.
         concatenate waHtml '<font' into waHtml.

*        Add the font name
         if not bodyFontName is initial.
            concatenate waHtml ' face ="' into waHtml.
            concatenate waHtml bodyFontName '"' into waHtml.
         endif.

*        Add the font colour
         if not bodyFontColour is initial.
            concatenate waHtml ' color ="' into waHtml.
            concatenate waHtml bodyFontColour '"' into waHtml.
         endif.

*        Add the fontsize
         if not bodyFontSize is initial.
            concatenate waHtml ' size ="' into waHtml.
            concatenate waHtml bodyFontSize '"' into waHtml.
         endif.

         concatenate waHtml '>' into waHtml.
         usedAFontAttribute = TRUE.
      endif.

*     Add the row number into the table
      concatenate waHtml loopCounter into waHtml.


      if usedAFontAttribute = TRUE.
        concatenate waHtml '</font>' into waHtml.
        usedAFontAttribute = FALSE.
      endif.

      concatenate waHtml '</td>' into waHtml.
      append waHtml to iLocHtml.
    endif.

    do.
*     Assign each field in the table to the field symbol
      assign component sy-index of structure <iLocDictStructure> to
<fsField>.
      If sy-subrc = 0.
        move <fsField> to wTextCell.

*       Cell data processing
        if BodyBackColour is initial.
          waHtml = '<td>'.
        else.
          concatenate '<td bgcolor="' bodyBackColour '">' into waHtml.
        endif.

        if not bodyFontName is initial or not bodyFontColour is initial
or not bodyFontSize is initial.
           concatenate waHtml '<font' into waHtml.

*          Add the font name
           if not bodyFontName is initial.
              concatenate waHtml ' face ="' into waHtml.
              concatenate waHtml bodyFontName '"' into waHtml.
           endif.

*          Add the font colour
           if not bodyFontColour is initial.
              concatenate waHtml ' color ="' into waHtml.
              concatenate waHtml bodyFontColour '"' into waHtml.
           endif.

*          Add the fontsize
           if not bodyFontSize is initial.
              concatenate waHtml ' size ="' into waHtml.
              concatenate waHtml bodyFontSize '"' into waHtml.
           endif.

           concatenate waHtml '>' into waHtml.
           usedAFontAttribute = TRUE.
        endif.

*       Add the caption name
        if wTextCell is initial.
          concatenate waHtml '&nbsp;' into waHtml.
        else.
          concatenate waHtml wTextCell into waHtml.
        endif.

        if usedAFontAttribute = TRUE.
          concatenate waHtml '</font>' into waHtml.
          usedAFontAttribute = FALSE.
        endif.

        concatenate waHtml '</td>' into waHtml.
        append waHtml to iLocHtml.
      else.
        exit.
      endif.
    enddo.

    append '</tr>' to iLocHtml.
  endLoop.

  append '</table>' to iLocHtml.
endform.
                             "convertITABtoHtml

*-----------------------------------------------------------------------
*  convertCodeToHtml... Builds an HTML table based upon a text table.
*-----------------------------------------------------------------------
form convertCodeToHtml using iContents like dumIHtml[]
                             value(programName)
                             value(ShortDescription)
                             value(sourceCodeType)
                             value(functionDocumentationExists)
                             value(isMainFunctionInclude)
                             value(syntaxHighlightComments)
                             value(htmlExtension)
                             value(customerNameRange)
                             value(getIncludes)
                             value(getDictStructures).

data: htmlTable type standard table of string with header line.
data: listingName type string value 'Code listing for:'.
data: descriptionName type string value `Description: `.
data: head(255).
data: tail(255).
data: myTabix type syTabix.
data: nextLine type syTabix.
data: hyperlinkName type string.
data: copyOfCurrentLine type string.
data: currentLineLength type i value 0.
data: copyLineLength type i value 0.
data: ignoreFutureLines type i value FALSE.
data: foundAsterix type i value FALSE.
data: lowercaseLink type string.
data: waNextLine type string.
data: waContent(255).

* Add a html header to the table
  perform addHTMLHeader using htmlTable[]
                              programName.

  concatenate listingName programName into listingName separated by
space.
  concatenate '<font size="3" face = "Arial" color="' COLOUR_BLACK
'"><b>' listingName '</b></font>' into htmlTable.
  append htmlTable.

  if not shortDescription is initial.
    append '<br>' to htmlTable.
    concatenate descriptionName shortDescription into descriptionName
separated by space.
    concatenate '<font size="3" face = "Arial" color="' COLOUR_BLACK
'"><b>' descriptionName '</b></font>' into htmlTable.
    append htmlTable.
  endif.

  htmlTable = '<hr>'.
  append htmlTable.

  htmlTable = '<pre width="100">'.
  append htmlTable.

  loop at iContents into waContent.
    myTabix = sy-tabix.

    if not ( iContents is initial ).
      while ( waContent cs '<' or waContent cs '>' ).
        replace '<' in waContent with LT.
        replace '>' in waContent with GT.
      endwhile.

      if waContent+0(1) <> ASTERIX.
        currentLineLength = strlen( waContent ).
        copyOfCurrentLine = waContent.

*       Don't hyperlink anything for files of type documentation
        if sourceCodeType <> IS_DOCUMENTATION.
*         Check for any functions to highlight
          if ( waContent cs CALLFUNCTION ) and ( waContent <>
'DESTINATION' ).
            nextLine = myTabix + 1.
            read table iContents into waNextLine index nextLine.
            translate waNextLine to upper case.
            if waNextLine ns 'DESTINATION'.
              shift copyOfCurrentLine left deleting leading space.

              copyLineLength = strlen( copyofCurrentLine ).

              split copyOfCurrentLine at space into head tail.
              split tail at space into head tail.
              split tail at space into head tail.
*             Function name is now in head
              translate head using ''' '.
              shift head left deleting leading space.

              try.
                if head+0(1) = 'Y' or head+0(1) = 'Z' or head+0(1) = 'y'
 or head+0(1) = 'z' or head cs customerNameRange.
*                 Definately a customer function module
                  hyperLinkName = head.

                  if sourceCodeType = IS_FUNCTION.
                    copyOfCurrentLine = 'call function <a href ="../'.
                  else.
                    copyOfCurrentLine = 'call function <a href ="'.
                  endif.

                  lowercaseLink = hyperlinkName.
                  translate lowercaseLink to lower case.
*                 If we are running on a non UNIX environment we will
* need to remove forward slashes
                  if frontendOpSystem = NON_UNIX.
                    translate lowercaseLink using '/_'.
                  endif.

                  concatenate copyOfCurrentLine
                              lowercaseLink     "hyperlinkName
                              '/'
                              lowercaseLink     "hyperlinkName
                              Period htmlExtension '">'
                              ''''
                              hyperlinkName
                              ''''
                              '</a>'
                              tail into copyOfCurrentLine.

*                 Pad the string back out with spaces
                  while copyLineLength < currentLineLength.
                    shift copyOfCurrentLine right by 1 places.
                    copyLineLength = copyLineLength + 1.
                  endwhile.

                  waContent = copyOfCurrentLine.
                endif.
                catch cx_sy_range_out_of_bounds into objRuntimeError.
              endtry.
            endif.
          endif.
        endif.

*       Check for any customer includes to hyperlink
        if waContent cs INCLUDE or waContent cs LOWINCLUDE.
          shift copyOfCurrentLine left deleting leading space.
          copyLineLength = strlen( copyOfCurrentLine ).

          split copyOfCurrentLine at space into head tail.
          shift tail left deleting leading space.

          try.
            if ( tail+0(1) = 'Y' or tail+0(1) = 'Z' or tail+0(1) = 'y'
or tail+0(1) = 'z' or tail cs customerNameRange or tail+0(2) = 'mz' or
tail+0(2) = 'MZ' )
                and not getIncludes is initial and  tail ns STRUCTURE
and tail ns LOWSTRUCTURE.

*             Hyperlink for program includes
              clear waContent.
              shift tail left deleting leading space.
              split tail at PERIOD into hyperlinkName tail.
              copyOfCurrentLine = 'include <a href ="'.

              lowercaseLink = hyperlinkName.
              translate lowercaseLink to lower case.

*             If we are running on a non UNIX environment we will need
*to remove forward slashes
              if frontendOpSystem = NON_UNIX.
                translate lowercaseLink using '/_'.
              endif.

              concatenate copyOfCurrentLine
                          lowercaseLink       "hyperlinkName
                          PERIOD htmlExtension '">'
                          hyperlinkName
                          '</a>'
                          PERIOD tail into copyOfCurrentLine.

*             Pad the string back out with spaces
              while copyLineLength < currentLineLength.
                shift copyOfCurrentLine right by 1 places.
                copyLineLength = copyLineLength + 1.
              endwhile.
              waContent = copyOfCurrentLine.
            else.
              if not getDictStructures is initial.
*              Hyperlink for structure include e.g. "include structure
* zfred."
               copyLineLength = strlen( copyofCurrentLine ).
               split copyOfCurrentLine at space into head tail.
               shift tail left deleting leading space.
               split tail at space into head tail.

               try.
                 if tail+0(1) = 'Y' or tail+0(1) = 'Z' or tail+0(1) =
'y' or tail+0(1) = 'z' or tail cs customerNameRange.
                   clear waContent.
                   shift tail left deleting leading space.
                   split tail at PERIOD into hyperlinkName tail.
                   copyOfCurrentLine = 'include structure <a href ='.

                   lowercaseLink = hyperlinkName.
                   translate lowercaseLink to lower case.
*                  If we are running on a non UNIX environment we will
* need to remove forward slashes
                   if frontendOpSystem = NON_UNIX.
                     translate lowercaseLink using '/_'.
                   endif.

                   concatenate copyOfCurrentLine
                               '"'
                               lowercaseLink    "hyperlinkName
                               '/'
                               'dictionary-'
                               lowercaseLink    "hyperlinkName
                               PERIOD htmlExtension
                               '">'
                               hyperlinkName
                               '</a>'
                               PERIOD tail into copyOfCurrentLine.

*                  Pad the string back out with spaces
                   while copyLineLength < currentLineLength.
                     shift copyOfCurrentLine right by 1 places.
                     copyLineLength = copyLineLength + 1.
                   endwhile.
                   waContent = copyOfCurrentLine.
                 endif.
                 catch cx_sy_range_out_of_bounds into objRuntimeError.
               endtry.
             endif.
           endif.
            catch cx_sy_range_out_of_bounds into objRuntimeError.
         endtry.
        endif.
     else.
       if not syntaxHighlightComments is initial and waContent+0(1) =
ASTERIX.
         concatenate '<font color ="' COMMENT_COLOUR '">' into head.
         concatenate head waContent '</font>' into tail.
         waContent = tail.
       endif.
     endif.

     htmlTable = waContent.

    else.
      htmlTable = ''.
    endif.
    append htmlTable.
  endloop.

  htmlTable = '</pre>'.
  append htmlTable.

* Add a html footer to the table
  perform addHtmlFooter using htmlTable[].

  iContents[] = htmlTable[].
endform.
                             "convertCodeToHtml

*-----------------------------------------------------------------------
*  convertClassToHtml... Builds an HTML table based upon a text table.
*-----------------------------------------------------------------------
form convertClassToHtml using iContents like dumIHtml[]
                              value(className)
                              value(ShortDescription)
                              value(sourceCodeType)
                              value(syntaxHighlightComments)
                              value(htmlExtension)
                              value(customerNameRange)
                              value(getDictStructures).

data: htmlTable type standard table of string with header line.
data: listingName type string value 'Code listing for class:'.
data: descriptionName type string value `Description: `.
data: myTabix type syTabix.
data: waContent(255).
data: head type string.
data: tail type string.
data: hyperlinkName type string.
data: lowercaseLink type string.
data: copyOfCurrentLine type string.
data: currentLineLength type i value 0.
data: copyLineLength type i value 0.

* Add a html header to the table
  perform addHTMLHeader using htmlTable[]
                              className.

  concatenate listingName className into listingName separated by space.
  concatenate '<font size="3" face = "Arial" color="' COLOUR_BLACK
'"><b>' listingName '</b></font>' into htmlTable.
  append htmlTable.

  if not shortDescription is initial.
    append '<br>' to htmlTable.
    concatenate descriptionName shortDescription into descriptionName
separated by space.
    concatenate '<font size="3" face = "Arial" color="' COLOUR_BLACK
'"><b>' descriptionName '</b></font>' into htmlTable.
    append htmlTable.
  endif.

  htmlTable = '<hr>'.
  append htmlTable.

  htmlTable = '<pre width="100">'.
  append htmlTable.

  loop at iContents into waContent.
    myTabix = sy-tabix.

*   Comments
    if not syntaxHighlightComments is initial and waContent+0(1) =
ASTERIX.
      concatenate '<font color ="' COMMENT_COLOUR '">' into head.
      concatenate head waContent '</font>' into waContent.
      htmlTable = waContent.
    else.
*     Smaller than, greater than signs
      if not ( iContents is initial ).
        while ( waContent cs '<' or waContent cs '>' ).
          replace '<' in waContent with LT.
          replace '>' in waContent with GT.
        endwhile.

*       Dictionary structures
        if not getDictStructures is initial.
          find 'class' in waContent ignoring case.
          if sy-subrc <> 0.
*           Hyperlink for dictionary/structure include
            copyLineLength = strlen( waContent ).
            copyOfCurrentLine = waContent.
            split copyOfCurrentLine at space into head tail.
            shift tail left deleting leading space.
            split tail at space into head tail.

            try.
              if tail+0(1) = 'Y' or tail+0(1) = 'Z' or tail+0(1) = 'y'
or tail+0(1) = 'z' or tail cs customerNameRange.
                clear waContent.
                shift tail left deleting leading space.
                split tail at PERIOD into hyperlinkName tail.
                copyOfCurrentLine = 'include structure <a href ='.

                lowercaseLink = hyperlinkName.
                translate lowercaseLink to lower case.
*               If we are running on a non UNIX environment we will need
* to remove forward slashes
                if frontendOpSystem = NON_UNIX.
                  translate lowercaseLink using '/_'.
                endif.

                concatenate copyOfCurrentLine
                            '"'
                            lowercaseLink    "hyperlinkName
                            '/'
                            'dictionary-'
                            lowercaseLink    "hyperlinkName
                            PERIOD htmlExtension
                            '">'
                            hyperlinkName
                            '</a>'
                            PERIOD tail into copyOfCurrentLine.

*               Pad the string back out with spaces
                while copyLineLength < currentLineLength.
                  shift copyOfCurrentLine right by 1 places.
                  copyLineLength = copyLineLength + 1.
                endwhile.
                waContent = copyOfCurrentLine.
              endif.
              catch cx_sy_range_out_of_bounds into objRuntimeError.
            endtry.
          endif.
        endif.

        htmlTable = waContent.
      else.
        htmlTable = ''.
      endif.
    endif.

    append htmlTable.
  endloop.

  htmlTable = '</pre>'.
  append htmlTable.

* Add a html footer to the table
  perform addHtmlFooter using htmlTable[].

  iContents[] = htmlTable[].
endform.
                            "convertClassToHtml

*-----------------------------------------------------------------------
*  convertFunctionToHtml... Builds an HTML table based upon a text table
*-----------------------------------------------------------------------
form convertFunctionToHtml using iContents like dumIHtml[]
                                 value(functionName)
                                 value(ShortDescription)
                                 value(sourceCodeType)
                                 value(functionDocumentationExists)
                                 value(isMainFunctionInclude)
                                 value(syntaxHighlightComments)
                                 value(htmlExtension)
                                 value(customerNameRange)
                                 value(getIncludes)
                                 value(getDictStructures).

data: htmlTable type standard table of string with header line.
data: listingName type string value 'Code listing for function:'.
data: descriptionName type string value `Description: `.
data: head(255).
data: tail(255).
data: myTabix type syTabix.
data: nextLine type syTabix.
data: hyperlinkName type string.
data: copyOfCurrentLine type string.
data: currentLineLength type i value 0.
data: copyLineLength type i value 0.
data: ignoreFutureLines type i value FALSE.
data: foundAsterix type i value FALSE.
data: lowercaseLink type string.
data: waNextLine type string.
data: waContent(255).

* Add a html header to the table
  perform addHTMLHeader using htmlTable[]
                              functionName.

  concatenate listingName functionName into listingName separated by
space.
  concatenate '<font size="3" face = "Arial" color="' COLOUR_BLACK
'"><b>' listingName '</b></font>' into htmlTable.
  append htmlTable.

  if not shortDescription is initial.
    append '<br>' to htmlTable.
    concatenate descriptionName shortDescription into descriptionName
separated by space.
    concatenate '<font size="3" face = "Arial" color="' COLOUR_BLACK
'"><b>' descriptionName '</b></font>' into htmlTable.
    append htmlTable.
  endif.

  htmlTable = '<hr>'.
  append htmlTable.

  htmlTable = '<pre width="100">'.
  append htmlTable.

  loop at iContents into waContent.
    myTabix = sy-tabix.

*   Extra code for adding global and doc hyperlinks to functions
    if sourceCodeType = IS_FUNCTION and isMainFunctionInclude = TRUE.
      if sy-tabix > 1.
        if waContent+0(1) = ASTERIX and ignoreFutureLines = FALSE.
          foundAsterix = TRUE.
        else.
          if foundAsterix = TRUE.
*           Lets add our extra HTML lines in here
            append '' to HtmlTable.

*           Global data hyperlink
            if not syntaxHighlightComments is initial.
              concatenate '<font color ="' COMMENT_COLOUR '">' into
copyOfCurrentLine.
            endif.

            concatenate copyOfCurrentLine '*       <a href ="' into
copyOfcurrentLine.
            lowercaseLink = functionName.
            translate lowercaseLink to lower case.
*           If we are running on a non UNIX environment we will need to
*remove forward slashes
            if frontendOpSystem = NON_UNIX.
              translate lowercaseLink using '/_'.
            endif.

           concatenate copyOfCurrentLine 'global-' lowercaseLink PERIOD htmlExtension '">' 'Global data declarations' '</a>' into copyOfCurrentLine.


            if not syntaxHighlightComments is initial.
              concatenate copyOfCurrentLine '</font>' into copyOfCurrentLine.
            endif.

            append copyOfCurrentLine to HtmlTable.

*           Documentation hyperlink.
            if functionDocumentationExists = TRUE.
              if not syntaxHighlightComments is initial.
                concatenate '<font color ="' COMMENT_COLOUR '">' into copyOfCurrentLine.
              endif.

              concatenate copyOfCurrentLine '*       <a href ="' into copyOfCurrentLine.

              lowercaseLink = functionName.
              translate lowercaseLink to lower case.
*             If we are running on a non UNIX environment we will need
*to remove forward slashes
              if frontendOpSystem = NON_UNIX.
                translate lowercaseLink using '/_'.
              endif.

              concatenate copyOfCurrentLine
                          'docs-'
                          lowercaseLink  "functionName
                          PERIOD htmlExtension '">'
                          'Function module documentation'
                          '</a>'
                          into copyOfCurrentLine.

              if not pComm is initial.
                concatenate copyOfCurrentLine '</font>' into
copyOfCurrentLine.
              endif.
              append copyOfCurrentLine to HtmlTable.
            endif.

            foundAsterix = FALSE.
            ignoreFutureLines = TRUE.
          endif.
        endif.
      endif.
    endif.

*   Carry on as normal
    if not ( iContents is initial ).
      while ( waContent cs '<' or waContent cs '>' ).
        replace '<' in waContent with LT.
        replace '>' in waContent with GT.
      endwhile.

      if waContent+0(1) <> ASTERIX.
        currentLineLength = strlen( waContent ).

*       Don't hyperlink anything for files of type documentation
        if sourceCodeType <> IS_DOCUMENTATION.
*       Check for any functions to highlight
          if ( waContent cs CALLFUNCTION ) and ( waContent <>
'DESTINATION' ).
            nextLine = myTabix + 1.
            read table iContents into waNextLine index nextLine.
            translate waNextLine to upper case.
            if waNextLine ns 'DESTINATION'.
              copyOfCurrentLine = waContent.
              shift copyOfCurrentLine left deleting leading space.

              copyLineLength = strlen( copyofCurrentLine ).

              split copyOfCurrentLine at space into head tail.
              split tail at space into head tail.
              split tail at space into head tail.
*             Function name is now in head
              translate head using ''' '.
              shift head left deleting leading space.

              try.
                if head+0(1) = 'Y' or head+0(1) = 'Z' or head+0(1) = 'y'
 or head+0(1) = 'z' or head cs customerNameRange.

*                 Definately a customer function module
                  hyperLinkName = head.

                  if sourceCodeType = IS_FUNCTION.
                    copyOfCurrentLine = 'call function <a href ="../'.
                  else.
                    copyOfCurrentLine = 'call function <a href ="'.
                  endif.

                  lowercaseLink = hyperlinkName.
                  translate lowercaseLink to lower case.
*                 If we are running on a non UNIX environment we will
*need to remove forward slashes
                  if frontendOpSystem = NON_UNIX.
                    translate lowercaseLink using '/_'.
                  endif.

                  concatenate copyOfCurrentLine
                              lowercaseLink     "hyperlinkName
                              '/'
                              lowercaseLink     "hyperlinkName
                              Period htmlExtension '">'
                              ''''
                              hyperlinkName
                              ''''
                              '</a>'
                              tail into copyOfCurrentLine.

*                 Pad the string back out with spaces
                  while copyLineLength < currentLineLength.
                    shift copyOfCurrentLine right by 1 places.
                    copyLineLength = copyLineLength + 1.
                  endwhile.

                  waContent = copyOfCurrentLine.
                endif.
                catch cx_sy_range_out_of_bounds into objRuntimeError.
              endtry.
            endif.
          endif.
        endif.

*       Check for any customer includes to hyperlink
        if waContent cs INCLUDE or waContent cs LOWINCLUDE.
          copyOfCurrentLine = waContent.

          shift copyOfCurrentLine left deleting leading space.
          copyLineLength = strlen( copyOfCurrentLine ).

          split copyOfCurrentLine at space into head tail.
          shift tail left deleting leading space.

          try.
            if ( tail+0(1) = 'Y' or tail+0(1) = 'Z' or tail+0(1) = 'y'
or tail+0(1) = 'z'
                 or tail cs customerNameRange or tail+0(2) = 'mz' or
tail+0(2) = 'MZ' ) and not getIncludes is initial.

*             Hyperlink for program includes
              clear waContent.
              shift tail left deleting leading space.
              split tail at PERIOD into hyperlinkName tail.
              copyOfCurrentLine = 'include <a href ="'.

              lowercaseLink = hyperlinkName.
              translate lowercaseLink to lower case.
*             If we are running on a non UNIX environment we will need
*to remove forward slashes
              if frontendOpSystem = NON_UNIX.
                translate lowercaseLink using '/_'.
              endif.

              concatenate copyOfCurrentLine
                          lowercaseLink       "hyperlinkName
                          PERIOD htmlExtension '">'
                          hyperlinkName
                          '</a>'
                          PERIOD tail into copyOfCurrentLine.

*             Pad the string back out with spaces
              while copyLineLength < currentLineLength.
                shift copyOfCurrentLine right by 1 places.
                copyLineLength = copyLineLength + 1.
              endwhile.
              waContent = copyOfCurrentLine.
            else.
              if not getDictStructures is initial.
*               Hyperlink for structure include
                copyLineLength = strlen( copyofCurrentLine ).
                split copyOfCurrentLine at space into head tail.
                shift tail left deleting leading space.
                split tail at space into head tail.

                try.
                  if tail+0(1) = 'Y' or tail+0(1) = 'Z' or tail+0(1) =
'y' or tail+0(1) = 'z' or tail cs customerNameRange.
                    clear waContent.
                    shift tail left deleting leading space.
                    split tail at PERIOD into hyperlinkName tail.
                    copyOfCurrentLine = 'include structure <a href ='.

                    lowercaseLink = hyperlinkName.
                    translate lowercaseLink to lower case.
*                   If we are running on a non UNIX environment we will
*need to remove forward slashes
                    if frontendOpSystem = NON_UNIX.
                      translate lowercaseLink using '/_'.
                    endif.

                    concatenate copyOfCurrentLine
                                '"'
                                lowercaseLink    "hyperlinkName
                                '/'
                                'dictionary-'
                                lowercaseLink    "hyperlinkName
                                PERIOD htmlExtension
                                '">'
                                hyperlinkName
                                '</a>'
                                PERIOD tail into copyOfCurrentLine.

*                   Pad the string back out with spaces
                    while copyLineLength < currentLineLength.
                      shift copyOfCurrentLine right by 1 places.
                      copyLineLength = copyLineLength + 1.
                    endwhile.
                    waContent = copyOfCurrentLine.
                  endif.
                  catch cx_sy_range_out_of_bounds into objRuntimeError.
                endtry.
              endif.
            endif.
            catch cx_sy_range_out_of_bounds into objRuntimeError.
         endtry.
       endif.
     else.
       if not syntaxHighlightComments is initial and waContent+0(1) =
ASTERIX.
         concatenate '<font color ="' COMMENT_COLOUR '">' into head.
         concatenate head waContent '</font>' into tail.
         waContent = tail.
       endif.
     endif.

     htmlTable = waContent.

    else.
      htmlTable = ''.
    endif.
    append htmlTable.
  endloop.

  htmlTable = '</pre>'.
  append htmlTable.

* Add a html footer to the table
  perform addHtmlFooter using htmlTable[].

  iContents[] = htmlTable[].
endform.
                         "convertFunctionToHtml

*-----------------------------------------------------------------------
*  buildColumnHeaders... build table column names
*-----------------------------------------------------------------------
form buildColumnHeaders using iLocColumnCaptions like dumiHtml[].

  append 'Row' to iLocColumnCaptions.
  append 'Field name' to iLocColumnCaptions.
  append 'Position' to iLocColumnCaptions.
  append 'Key' to iLocColumnCaptions.
  append 'Data element' to iLocColumnCaptions.
  append 'Domain' to iLocColumnCaptions.
  append 'Datatype' to iLocColumnCaptions.
  append 'Length' to iLocColumnCaptions.
  append 'Domain text' to iLocColumnCaptions.
endform.
                            "buildColumnHeaders

*-----------------------------------------------------------------------
* addHTMLHeader...  add a html formatted header to our output table
*-----------------------------------------------------------------------
form addHTMLHeader using iLocHeader like dumiHtml[]
                         value(title).

data: waHeader type string.

  append '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">' to
iLocHeader.
  append '<html>' to iLocHeader.
  append '<head>' to iLocHeader.

  concatenate '<title>' title '</title>' into waHeader.
  append waHeader to ilocHeader.

  append '</head>' to iLocHeader.

  if not pBack is initial.
    concatenate '<body bgcolor="' BACKGROUND_COLOUR '">' into waHeader.
  else.
    concatenate '<body bgcolor="' COLOUR_WHITE '">' into waHeader.
  endif.

  append waHeader to iLocHeader.
endform.
                                 "addHTMLHeader

*-----------------------------------------------------------------------
* addHTMLFooter...  add a html formatted footer to our output table
*-----------------------------------------------------------------------
form addHTMLFooter using iLocFooter like dumiHtml[].

data: footerMessage type string.
data: waFooter type string.

  perform buildFooterMessage using 'HTML'
                                   footerMessage.

  append '<hr>' to iLocFooter.
  concatenate '<font size="2" face = "Sans Serif">' footerMessage into
waFooter.
  append waFooter to iLocFooter.
  append '</font>' to iLocFooter.
  append '</body>' to iLocFooter.
  append '</html>' to iLocFooter.
endform.
                                 "addHTMLFooter

*-----------------------------------------------------------------------
* buildFooterMessage...Returns a footer message based on the output file
* type.
*-----------------------------------------------------------------------
form buildFooterMessage using fileType
                              returnMessage.

  if fileType = 'HTML'.
    concatenate `Extracted by Direct Download Enterprise version `
                 VERSIONNO ` - E.G.Mellodew. 1998-2005 UK. Sap Release `
 sy-saprl
                into returnMessage.
  else.
    concatenate `Extracted by Direct Download Enterprise version `
                 VERSIONNO ` - E.G.Mellodew. 1998-2005 UK. Sap Release `
 sy-saprl
                into returnMessage.
  endif.
endform.
                            "buildFooterMessage

************************************************************************
***********************************************
********************************************DISPLAY
*ROUTINES***********************************************************
************************************************************************
***********************************************

*-----------------------------------------------------------------------
*  fillTreeNodeTables...
*-----------------------------------------------------------------------
form fillTreeNodeTables using iLocDictionary like iDictionary[]
                              iLocTreeDisplay like iTreeDisplay[]
                              value(runTime).

data: tableLines type i.
data: waTreeDisplay like sNodeText.
field-symbols: <waDictionary> type tDictTable.
data: tableLinesString type string.
data: runtimeChar(10).
data: subLevel type string.

  tableLines = lines( iLocDictionary ).
  tableLinesString = tableLines.

  if tableLines = 1.
    concatenate tableLinesString 'table downloaded' into
waTreeDisplay-text2 separated by space.
  else.
    concatenate tableLinesString 'tables downloaded' into
 waTreeDisplay-text2 separated by space.
  endif.

  write runTime to runtimeChar.
  concatenate waTreeDisplay-text2 '- runtime' runTimeChar into
waTreeDisplay-text2 separated by space.

* include header display record.
  waTreeDisplay-tlevel = '1'.
  waTreeDisplay-tlength2  = 60.
  waTreeDisplay-tcolor2    = 1.
  append waTreeDisplay to iLocTreeDisplay.

  loop at iLocDictionary assigning <waDictionary>.
    waTreeDisplay-tlevel = '2'.
    waTreeDisplay-text2 = <waDictionary>-tablename.
    waTreeDisplay-tcolor2    = 3.
    waTreeDisplay-tlength3   = 80.
    waTreeDisplay-tcolor3    = 3.
    waTreeDisplay-tpos3      = 60.
    concatenate 'Dictionary:' <waDictionary>-tableTitle into
waTreeDisplay-text3 separated by space.

    append waTreeDisplay to iLocTreeDisplay.
  endloop.
endform.
                            "fillTreeNodeTables

*-----------------------------------------------------------------------
*  fillTreeNodeMessages...
*-----------------------------------------------------------------------
form fillTreeNodeMessages using iLocMessages like iMessages[]
                                iLocTreeDisplay like iTreeDisplay[]
                                value(runTime).

data: tableLines type i.
data: waTreeDisplay like sNodeText.
field-symbols: <waMessage> type tMessage.
data: tableLinesString type string.
data: runtimeChar(10).

  sort iLocMessages ascending by arbgb.

  loop at iLocMessages assigning <waMessage>.
    at new arbgb.
      tableLines = tableLines + 1.
    endat.
  endloop.
  tableLinesString = tableLines.

  if tableLines = 1.
    concatenate tableLinesString 'message class downloaded' into
waTreeDisplay-text2 separated by space.
  else.
    concatenate tableLinesString 'message classes downloaded' into
waTreeDisplay-text2 separated by space.
  endif.

  write runTime to runTimeChar.
  concatenate waTreeDisplay-text2 '- runtime' runTimeChar into
waTreeDisplay-text2 separated by space.

* include header display record.
  waTreeDisplay-tlevel = '1'.
  waTreeDisplay-tlength2 = 60.
  waTreeDisplay-tcolor2 = 1.
  append waTreeDisplay to iLocTreeDisplay.

  loop at iLocMessages assigning <waMessage>.
    at new arbgb.
      waTreeDisplay-tlevel = '2'.
      waTreeDisplay-text2 = <waMessage>-arbgb.
      waTreeDisplay-tcolor2    = 5.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 5.
      waTreeDisplay-tpos3      = 60.
      waTreeDisplay-text3 = <waMessage>-sText.
      concatenate 'Message class:'  waTreeDisplay-text3 into
waTreeDisplay-text3 separated by space.
      append waTreeDisplay to iLocTreeDisplay.
    endat.
  endloop.
endform.
                          "fillTreeNodeMessages

*-----------------------------------------------------------------------
*  fillTreeNodeFunctions...
*-----------------------------------------------------------------------
form fillTreeNodeFunctions using iLocFunctions like iFunctions[]
                                 iLocTreeDisplay like iTreeDisplay[]
                                 value(runTime).

data: tableLines type i.
data: waTreeDisplay like sNodeText.
field-symbols: <waFunction> type tFunction.
field-symbols: <waScreen> type tScreenFlow.
field-symbols: <waGUITitle> type tGUITitle.
field-symbols: <waDictionary> type tDictTable.
field-symbols: <waInclude> type tInclude.
field-symbols: <waMessage> type tMessage.
data: tableLinesString type string.
data: runtimeChar(10).

  sort iLocFunctions ascending by functionName.

  tableLines = lines( iLocFunctions ).
  tableLinesString = tableLines.

  if tableLines = 1.
    concatenate tableLinesString ` function downloaded` into
waTreeDisplay-text2.
  else.
    concatenate tableLinesString ` functions downloaded` into
waTreeDisplay-text2.
  endif.

  write runTime to runTimeChar.

  concatenate waTreeDisplay-text2 ` - runtime ` runTimeChar into
waTreeDisplay-text2.
* include header display record.
  waTreeDisplay-tlevel = '1'.
  waTreeDisplay-tlength2  = 60.
  waTreeDisplay-tcolor2    = 1.
  append waTreeDisplay to iLocTreeDisplay.

* Lets fill the detail in
  loop at iLocFunctions assigning <wafunction>.
    waTreeDisplay-tlevel = 2.
    waTreeDisplay-text2 = <wafunction>-functionName.
    waTreeDisplay-tcolor2    = 7.
    waTreeDisplay-tlength3   = 80.
    waTreeDisplay-tcolor3    = 7.
    waTreeDisplay-tpos3      = 60.
    concatenate `Function: ` <wafunction>-functionName into
waTreeDisplay-text3.
    append waTreeDisplay to iLocTreeDisplay.

*   Screens.
    loop at <waFunction>-iScreenFlow assigning <waScreen>.
      waTreeDisplay-tlevel = '2'.
      waTreeDisplay-text2 = <waScreen>-screen.
      waTreeDisplay-tcolor2    = 6.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 6.
      waTreeDisplay-tpos3      = 60.
      waTreeDisplay-text3 = 'Screen'.
      append waTreeDisplay to iTreeDisplay.
    endloop.

*   GUI Title.
    loop at <waFunction>-iGUITitle assigning <waGUITitle>.
      waTreeDisplay-tlevel = '2'.
      waTreeDisplay-text2 = <waGUITitle>-obj_code.
      waTreeDisplay-tcolor2    = 6.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 6.
      waTreeDisplay-tpos3      = 60.
      waTreeDisplay-text3 = 'GUI Title'.
      append waTreeDisplay to iTreeDisplay.
    endloop.

*   Fill in the tree with include information
    loop at <waFunction>-iIncludes assigning <waInclude>.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 =  <waInclude>-includeName.
      waTreeDisplay-tcolor2    = 4.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 4.
      waTreeDisplay-tpos3      = 60.
      concatenate `Include:   ` <waInclude>-includeTitle into
waTreeDisplay-text3.
      append waTreeDisplay to iLocTreeDisplay.
    endloop.

*   fill in the tree with dictionary information
    loop at <waFunction>-iDictStruct assigning <waDictionary>.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 =  <waDictionary>-tablename.
      waTreeDisplay-tcolor2    = 3.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 3.
      waTreeDisplay-tpos3      = 60.
      concatenate `Dictionary:` <waDictionary>-tableTitle into
waTreeDisplay-text3.
      append waTreeDisplay to iLocTreeDisplay.
    endloop.

*   fill in the tree with message information
    sort <waFunction>-iMessages[] ascending by arbgb.
    loop at <waFunction>-iMessages assigning <waMessage>.
      at new arbgb.
        waTreeDisplay-tlevel = 3.
        waTreeDisplay-text2 = <waMessage>-arbgb.
        waTreeDisplay-tcolor2    = 5.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 5.
        waTreeDisplay-tpos3      = 60.

*       Select the message class text if we do not have it already
        if <waMessage>-sText is initial.
          select single stext from t100a
                              into <waMessage>-stext
                              where arbgb = <waMessage>-arbgb.
        endif.

        waTreeDisplay-text3 = <waMessage>-sText.
        concatenate `Message class: `  waTreeDisplay-text3 into
waTreeDisplay-text3.
        append waTreeDisplay to iLocTreeDisplay.
      endat.
    endloop.
  endloop.
endform.
                         "fillTreeNodeFunctions

*-----------------------------------------------------------------------
*  fillTreeNodePrograms
*-----------------------------------------------------------------------
form fillTreeNodePrograms using iLocPrograms like iPrograms[]
                                iLocFunctions like iFunctions[]
                                iLocTreeDisplay like iTreeDisplay[]
                                value(runTime).

data: tableLines type i.
data: waTreeDisplay like sNodeText.
field-symbols: <waProgram> type tProgram.
field-symbols: <waScreen> type tScreenFlow.
field-symbols: <waFunction> type tFunction.
field-symbols: <waDictionary> type tDictTable.
field-symbols: <waInclude> type tInclude.
field-symbols: <waMessage> type tMessage.
data: tableLinesString type string.
data: runtimeChar(10).

  tableLines = lines( iLocPrograms ).
  tableLinesString = tableLines.

  if tableLines = 1.
    concatenate tableLinesString ` program downloaded` into
waTreeDisplay-text2.
  else.
    concatenate tableLinesString ` programs downloaded` into
waTreeDisplay-text2.
  endif.

  write runTime to runTimeChar.

  concatenate waTreeDisplay-text2 ` - runtime ` runTimeChar into
waTreeDisplay-text2.
* include header display record.
  waTreeDisplay-tlevel = '1'.
  waTreeDisplay-tlength2  = 60.
  waTreeDisplay-tcolor2    = 1.
  append waTreeDisplay to iTreeDisplay.

  loop at iLocPrograms assigning <waProgram>.
*   Main programs.
    waTreeDisplay-tlevel = '2'.
    waTreeDisplay-text2 = <waProgram>-progName.
    waTreeDisplay-tcolor2    = 1.
*   Description
    waTreeDisplay-tlength3   = 80.
    waTreeDisplay-tcolor3    = 1.
    waTreeDisplay-tpos3      = 60.
    concatenate `Program: ` <waProgram>-programTitle into
 waTreeDisplay-text3.
    append waTreeDisplay to iTreeDisplay.
*   Screens.
    loop at <waProgram>-iScreenFlow assigning <waScreen>.
      waTreeDisplay-tlevel = '3'.
      waTreeDisplay-text2 = <waScreen>-screen.
      waTreeDisplay-tcolor2    = 6.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 6.
      waTreeDisplay-tpos3      = 60.
      waTreeDisplay-text3 = 'Screen'.
      append waTreeDisplay to iTreeDisplay.
    endloop.
*   fill in the tree with message information
    sort <waProgram>-iMessages[] ascending by arbgb.
    loop at <waProgram>-iMessages assigning <waMessage>.
      at new arbgb.
        waTreeDisplay-tlevel = 3.
        waTreeDisplay-text2 = <waMessage>-arbgb.
        waTreeDisplay-tcolor2    = 5.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 5.
        waTreeDisplay-tpos3      = 60.

*       Select the message class text if we do not have it already
        if <waMessage>-sText is initial.
          select single stext from t100a
                              into <waMessage>-stext
                              where arbgb = <waMessage>-arbgb.
        endif.

        waTreeDisplay-text3 = <waMessage>-sText.
        concatenate `Message class: `  waTreeDisplay-text3 into
waTreeDisplay-text3.
        append waTreeDisplay to iLocTreeDisplay.
      endat.
    endloop.
*   Fill in the tree with include information
    loop at <waProgram>-iIncludes assigning <waInclude>.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 =  <waInclude>-includeName.
      waTreeDisplay-tcolor2    = 4.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 4.
      waTreeDisplay-tpos3      = 60.
      concatenate `Include:   ` <waInclude>-includeTitle into
waTreeDisplay-text3.
      append waTreeDisplay to iLocTreeDisplay.
    endloop.
*   fill in the tree with dictionary information
    loop at <waProgram>-iDictStruct assigning <waDictionary>.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 =  <waDictionary>-tablename.
      waTreeDisplay-tcolor2    = 3.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 3.
      waTreeDisplay-tpos3      = 60.
      concatenate `Dictionary:    ` <waDictionary>-tableTitle into
waTreeDisplay-text3.
      append waTreeDisplay to iLocTreeDisplay.
    endloop.

*   Function Modules
    loop at iLocFunctions assigning <wafunction> where programLinkName =
 <waProgram>-progname.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 = <wafunction>-functionName.
      waTreeDisplay-tcolor2    = 7.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 7.
      waTreeDisplay-tpos3      = 60.
      concatenate `Function:      ` <wafunction>-functionName into
waTreeDisplay-text3.
      append waTreeDisplay to iLocTreeDisplay.

*     Fill in the tree with include information
      loop at <waFunction>-iIncludes assigning <waInclude>.
        waTreeDisplay-tlevel = 4.
        waTreeDisplay-text2 =  <waInclude>-includeName.
        waTreeDisplay-tcolor2    = 4.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 4.
        waTreeDisplay-tpos3      = 60.
        concatenate `Include:       ` <waInclude>-includeTitle into
waTreeDisplay-text3.
        append waTreeDisplay to iLocTreeDisplay.
      endloop.

*     fill in the tree with dictionary information
      loop at <waFunction>-iDictStruct assigning <waDictionary>.
        waTreeDisplay-tlevel = 4.
        waTreeDisplay-text2 =  <waDictionary>-tablename.
        waTreeDisplay-tcolor2    = 3.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 3.
        waTreeDisplay-tpos3      = 60.
        concatenate `Dictionary:    ` <wadictionary>-tableTitle into
waTreeDisplay-text3.
        append waTreeDisplay to iLocTreeDisplay.
      endloop.

*     fill in the tree with message information
      sort <waFunction>-iMessages[] ascending by arbgb.
      loop at <waFunction>-iMessages assigning <waMessage>.
        at new arbgb.
          waTreeDisplay-tlevel = 4.
          waTreeDisplay-text2 = <waMessage>-arbgb.
          waTreeDisplay-tcolor2    = 5.
          waTreeDisplay-tlength3   = 80.
          waTreeDisplay-tcolor3    = 5.
          waTreeDisplay-tpos3      = 60.

*         Select the message class text if we do not have it already
          if <waMessage>-sText is initial.
            select single stext from t100a
                                into <waMessage>-stext
                                where arbgb = <waMessage>-arbgb.
          endif.

          waTreeDisplay-text3 = <waMessage>-sText.
          concatenate `Message class:  `  waTreeDisplay-text3 into
waTreeDisplay-text3.
          append waTreeDisplay to iLocTreeDisplay.
        endat.
      endloop.
    endloop.
  endloop.
endform.
                          "fillTreeNodePrograms

*-----------------------------------------------------------------------
*  fillTreeNodeClasses
*-----------------------------------------------------------------------
form fillTreeNodeClasses using iLocClasses like iClasses[]
                               iLocFunctions like iFunctions[]
                               iLocTreeDisplay like iTreeDisplay[]
                               value(runTime).

data: tableLines type i.
data: waTreeDisplay like sNodeText.
field-symbols: <waClass> type tClass.
field-symbols: <waMethod> type tMethod.
field-symbols: <waFunction> type tFunction.
field-symbols: <waDictionary> type tDictTable.
field-symbols: <waInclude> type tInclude.
field-symbols: <waMessage> type tMessage.
data: tableLinesString type string.
data: runtimeChar(10).

  tableLines = lines( iLocClasses ).
  tableLinesString = tableLines.

  if tableLines = 1.
    concatenate tableLinesString ` class downloaded` into
 waTreeDisplay-text2.
  else.
    concatenate tableLinesString ` classes downloaded` into
waTreeDisplay-text2.
  endif.

  write runTime to runTimeChar.

  concatenate waTreeDisplay-text2 ` - runtime ` runTimeChar into
waTreeDisplay-text2.
* include header display record.
  waTreeDisplay-tlevel = '1'.
  waTreeDisplay-tlength2  = 60.
  waTreeDisplay-tcolor2    = 1.
  append waTreeDisplay to iTreeDisplay.

  loop at iLocClasses assigning <waClass>.
*   Main Class.
    waTreeDisplay-tlevel = '2'.
    waTreeDisplay-text2 = <waClass>-clsName.
    waTreeDisplay-tcolor2    = 1.
*   Description
    waTreeDisplay-tlength3   = 80.
    waTreeDisplay-tcolor3    = 1.
    waTreeDisplay-tpos3      = 60.
    concatenate `Class:    ` <waClass>-descript into waTreeDisplay-text3
.
    append waTreeDisplay to iTreeDisplay.

*   fill in the tree with method information
    loop at <waClass>-iMethods[] assigning <waMethod>.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 =  <waMethod>-cmpname.
      waTreeDisplay-tcolor2    = 2.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 2.
      waTreeDisplay-tpos3      = 60.
      concatenate `Method:   ` <waMethod>-descript into
waTreeDisplay-text3.
      append waTreeDisplay to iLocTreeDisplay.
    endloop.

*   fill in the tree with message information
    sort <waClass>-iMessages[] ascending by arbgb.
    loop at <waClass>-iMessages assigning <waMessage>.
      at new arbgb.
        waTreeDisplay-tlevel = 3.
        waTreeDisplay-text2 = <waMessage>-arbgb.
        waTreeDisplay-tcolor2    = 5.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 5.
        waTreeDisplay-tpos3      = 60.

*       Select the message class text if we do not have it already
        if <waMessage>-sText is initial.
          select single stext from t100a
                              into <waMessage>-stext
                              where arbgb = <waMessage>-arbgb.
        endif.

        waTreeDisplay-text3 = <waMessage>-sText.
        concatenate `Message class: `  waTreeDisplay-text3 into
waTreeDisplay-text3.
        append waTreeDisplay to iLocTreeDisplay.
      endat.
    endloop.

*   fill in the tree with dictionary information
    loop at <waClass>-iDictStruct assigning <waDictionary>.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 =  <waDictionary>-tablename.
      waTreeDisplay-tcolor2    = 3.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 3.
      waTreeDisplay-tpos3      = 60.
      concatenate `Dictionary:    ` <waDictionary>-tableTitle into
waTreeDisplay-text3.
      append waTreeDisplay to iLocTreeDisplay.
    endloop.

*   Function Modules
    loop at iLocFunctions assigning <wafunction> where programLinkName =
 <waClass>-clsname.
      waTreeDisplay-tlevel = 3.
      waTreeDisplay-text2 = <wafunction>-functionName.
      waTreeDisplay-tcolor2    = 7.
      waTreeDisplay-tlength3   = 80.
      waTreeDisplay-tcolor3    = 7.
      waTreeDisplay-tpos3      = 60.
      concatenate `Function:      ` <wafunction>-functionName into
waTreeDisplay-text3.
      append waTreeDisplay to iLocTreeDisplay.

*     Fill in the tree with include information
      loop at <waFunction>-iIncludes assigning <waInclude>.
        waTreeDisplay-tlevel = 4.
        waTreeDisplay-text2 =  <waInclude>-includeName.
        waTreeDisplay-tcolor2    = 4.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 4.
        waTreeDisplay-tpos3      = 60.
        concatenate `Include:       ` <waInclude>-includeTitle into
waTreeDisplay-text3.
        append waTreeDisplay to iLocTreeDisplay.
      endloop.

*     fill in the tree with dictionary information
      loop at <waFunction>-iDictStruct assigning <waDictionary>.
        waTreeDisplay-tlevel = 4.
        waTreeDisplay-text2 =  <waDictionary>-tablename.
        waTreeDisplay-tcolor2    = 3.
        waTreeDisplay-tlength3   = 80.
        waTreeDisplay-tcolor3    = 3.
        waTreeDisplay-tpos3      = 60.
        concatenate `Dictionary:    ` <wadictionary>-tableTitle into
waTreeDisplay-text3.
        append waTreeDisplay to iLocTreeDisplay.
      endloop.

*     fill in the tree with message information
      sort <waFunction>-iMessages[] ascending by arbgb.
      loop at <waFunction>-iMessages assigning <waMessage>.
        at new arbgb.
          waTreeDisplay-tlevel = 4.
          waTreeDisplay-text2 = <waMessage>-arbgb.
          waTreeDisplay-tcolor2    = 5.
          waTreeDisplay-tlength3   = 80.
          waTreeDisplay-tcolor3    = 5.
          waTreeDisplay-tpos3      = 60.

*         Select the message class text if we do not have it already
          if <waMessage>-sText is initial.
            select single stext from t100a
                                into <waMessage>-stext
                                where arbgb = <waMessage>-arbgb.
          endif.

          waTreeDisplay-text3 = <waMessage>-sText.
          concatenate `Message class:  `  waTreeDisplay-text3 into
waTreeDisplay-text3.
          append waTreeDisplay to iLocTreeDisplay.
        endat.
      endloop.
    endloop.
  endloop.
endform.
                           "fillTreeNodeClasses

*-----------------------------------------------------------------------
* displayTree...
*-----------------------------------------------------------------------
form displayTree using iLocTreeDisplay like iTreeDisplay[].

data: waTreeDisplay type snodetext.

* build up the tree from the internal table node
  call function 'RS_TREE_CONSTRUCT'
       tables
            nodetab            = iTreeDisplay
       exceptions
            tree_failure       = 1
            id_not_found       = 2
            wrong_relationship = 3
            others             = 4.

* get the first index and expand the whole tree
  read table iLoctreeDisplay into waTreeDisplay index 1.
  call function 'RS_TREE_EXPAND'
       exporting
            node_id   = waTreeDisplay-id
            all       = 'X'
       exceptions
            not_found = 1
            others    = 2.

* now display the tree
  call function 'RS_TREE_LIST_DISPLAY'
       exporting
            callback_program      = sy-cprog
            callback_user_command = 'CB_USER_COMMAND'
            callback_text_display = 'CB_text_DISPLAY'
            callback_top_of_page  = 'TOP_OF_PAGE'
       exceptions
            others                = 1.
endform.
                                   "displayTree

*-----------------------------------------------------------------------
*  topOfPage... for tree display routines.
*-----------------------------------------------------------------------
form topOfPage.

endform.


*Messages
*----------------------------------------------------------
*
* Message class: OO
*000   & & & &---------------------------------------------------------------------------------- Extracted by Direct Download Enterprise version 1.3.1 - E.G.Mellodew. 1998-2005 UK. Sap Release 620

*Text elements
*----------------------------------------------------------
* 001 Seleo de programas
* 002 Opes adicionais


*Selection texts
*----------------------------------------------------------
* CDAT         Data de criao
* CNAM         Autor
* INCL         Download tambm de includes
* PATH1         Diretrio
* PROGRAM         Nome do programa
* TELA         Download tambm de telas
* UDAT         Data da modificao
* UNAM         ltimo modificador


*Messages
*----------------------------------------------------------
*
* Message class: OO
*000   & & & &

*----------------------------------------------------------------------------------
*Extracted by Direct Download Enterprise version 1.3.1 - E.G.Mellodew. 1998-2005 UK. Sap Release 700